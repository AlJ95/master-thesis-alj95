<!doctype html><html itemscope itemtype=http://schema.org/WebPage lang=en class=no-js><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>etcd API guarantees | etcd</title>
<meta name=description content="API guarantees made by etcd"><meta property="og:url" content="https://etcd.io/docs/v3.5/learning/api_guarantees/"><meta property="og:site_name" content="etcd"><meta property="og:title" content="etcd API guarantees"><meta property="og:description" content="API guarantees made by etcd"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="docs"><meta property="article:modified_time" content="2025-01-12T17:56:02+00:00"><meta itemprop=name content="etcd API guarantees"><meta itemprop=description content="API guarantees made by etcd"><meta itemprop=dateModified content="2025-01-12T17:56:02+00:00"><meta itemprop=wordCount content="992"><meta name=twitter:card content="summary"><meta name=twitter:title content="etcd API guarantees"><meta name=twitter:description content="API guarantees made by etcd"></head><body class=td-page><div class="container-fluid td-outer"><div class=td-main><div class="row flex-xl-nowrap"><main class="col-12 col-md-9 col-xl-8 ps-md-5" role=main><div class=td-content><h1>etcd API guarantees</h1><div class=lead>API guarantees made by etcd</div><p>etcd is a consistent and durable key value store.
The key value store is exposed through <a href=../api/#grpc-services>gRPC Services</a>.
etcd ensures the strongest consistency and durability guarantees for a distributed system.
This specification enumerates the API guarantees made by etcd.</p><h3 id=apis-to-consider>APIs to consider</h3><ul><li>KV APIs<ul></ul></li><li>Watch APIs<ul></ul></li><li>Lease APIs<ul><li>[Revoke]</li></ul></li></ul><p>KV API allows for direct reading and manipulation of key value store.
Watch API allows subscribing to key value store changes.
Lease API allows assigning a time to live to a key.</p><p>Both KV and Watch APIs allow access to not only the latest versions of keys, but
also previous versions are accessible within a continuous history window, limited
by a compaction operation.</p><p>Calling KV API will take an immediate effect, while Watch API will return with some unbounded delay.
In correctly working etcd cluster you should expect to see watch events to appear with 10ms delay after them happening.
However, there is no limit and events in unhealthy clusters might never arrive.</p><h2 id=kv-apis>KV APIs</h2><p>etcd ensures durability and strict serializability for all KV api calls.
Those are the strongest isolation guarantee of distributed transactional database systems.</p><h3 id=durability>Durability</h3><p>Any completed operations are durable. All accessible data is also durable data.
A read will never return data that has not been made durable.</p><h3 id=strict-serializability>Strict serializability</h3><p>KV Service operations are atomic and occur in a total order, consistent with
real-time order of those operations. Total order is implied through <a href=#revision>revision</a>.
Read more about <a href=http://jepsen.io/consistency/models/strict-serializable target=_blank rel=noopener>strict serializability</a>.</p><p>Strict serializability implies other weaker guarantees that might be easier to understand:</p><h4 id=atomicity>Atomicity</h4><p>All API requests are atomic; an operation either completes entirely or not at
all. For watch requests, all events generated by one operation will be in one
watch response. Watch never observes partial events for a single operation.</p><h4 id=linearizability>Linearizability</h4><p>From the perspective of client, linearizability provides useful properties which
make reasoning easily. This is a clean description quoted from
<a href=https://cs.brown.edu/~mph/HerlihyW90/p463-herlihy.pdf target=_blank rel=noopener>the original paper</a>: <code>Linearizability provides the illusion that each operation applied by concurrent processes takes effect instantaneously at some point between its invocation and its response.</code></p><p>For example, consider a client completing a write at time point 1 (<em>t1</em>). A
client issuing a read at <em>t2</em> (for <em>t2</em> > <em>t1</em>) should receive a value at least
as recent as the previous write, completed at <em>t1</em>. However, the read might
actually complete only by <em>t3</em>. Linearizability guarantees the read returns the
most current value. Without linearizability guarantee, the returned value,
current at <em>t2</em> when the read began, might be &ldquo;stale&rdquo; by <em>t3</em> because a
concurrent write might happen between <em>t2</em> and <em>t3</em>.</p><p>etcd ensures linearizability for all other operations by default.
Linearizability comes with a cost, however, because linearized requests must go
through the Raft consensus process. To obtain lower latencies and higher
throughput for read requests, clients can configure a request’s consistency
mode to <code>serializable</code>, which may access stale data with respect to quorum, but
removes the performance penalty of linearized accesses&rsquo; reliance on live consensus.</p><h2 id=watch-apis>Watch APIs</h2><p>Watches make guarantees about events:</p><ul><li>Ordered - events are ordered by revision.
An event will never appear on a watch if it precedes an event in time that
has already been posted.</li><li>Unique - an event will never appear on a watch twice.</li><li>Reliable - a sequence of events will never drop any subsequence of events
within the available history window. If there are events ordered in time as
a &lt; b &lt; c, then if the watch receives events a and c, it is guaranteed to
receive b as long b is in the available history window.</li><li>Atomic - a list of events is guaranteed to encompass complete revisions.
Updates in the same revision over multiple keys will not be split over several
lists of events.</li><li>Resumable - A broken watch can be resumed by establishing a new watch starting
after the last revision received in a watch event before the break, so long as
the revision is in the history window.</li><li>Bookmarkable - Progress notification events guarantee that all events up to a
revision have been already delivered.</li></ul><p>etcd does not ensure linearizability for watch operations. Users are expected
to verify the revision of watch events to ensure correct ordering with other operations.</p><h2 id=lease-apis>Lease APIs</h2><p>etcd provides <a href=https://web.stanford.edu/class/cs240/readings/leases.pdf target=_blank rel=noopener>a lease mechanism</a>. The primary use case of a lease is
implementing distributed coordination mechanisms like distributed locks. The
lease mechanism itself is simple: a lease can be created with the grant API,
attached to a key with the put API, revoked with the revoke API, and will be
expired by the wall clock time to live (TTL). However, users need to be aware
about <a href=../why/#notes-on-the-usage-of-lock-and-lease>the important properties of the APIs and usage</a> for implementing
correct distributed coordination mechanisms.</p><h2 id=etcd-specific-definitions>etcd specific definitions</h2><h3 id=operation-completed>Operation completed</h3><p>An etcd operation is considered complete when it is committed through consensus,
and therefore “executed” -- permanently stored -- by the etcd storage engine.
The client knows an operation is completed when it receives a response from the
etcd server. Note that the client may be uncertain about the status of an
operation if it times out, or there is a network disruption between the client
and the etcd member. etcd may also abort operations when there is a leader
election. etcd does not send <code>abort</code> responses to clients’ outstanding requests
in this event.</p><h3 id=revision>Revision</h3><p>An etcd operation that modifies the key value store is assigned a single
increasing revision. A transaction operation might modify the key value store
multiple times, but only one revision is assigned. The revision attribute of a
key value pair that was modified by the operation has the same value as the
revision of the operation. The revision can be used as a logical clock for key
value store. A key value pair that has a larger revision is modified after a key
value pair with a smaller revision. Two key value pairs that have the same
revision are modified by an operation &ldquo;concurrently&rdquo;.</p><div class=d-print-none><h2 class=feedback--title>Feedback</h2><p class=feedback--question>Was this page helpful?</p><button class="btn btn-primary mb-4 feedback--answer feedback--answer-yes">Yes</button>
<button class="btn btn-primary mb-4 feedback--answer feedback--answer-no">No</button><p class="feedback--response feedback--response-yes">Glad to hear it! Please <a href=https://github.com/etcd-io/website/issues/new>tell us how we can improve</a>.</p><p class="feedback--response feedback--response-no">Sorry to hear that. Please <a href=https://github.com/etcd-io/website/issues/new>tell us how we can improve</a>.</p></div><br><div class=td-page-meta__lastmod>Last modified January 12, 2025: <a href=https://github.com/etcd-io/website/commit/d807822749d70b60a903ed19cc8a22634af0e527>fix leases broken link (d807822)</a></div></div></main></div></div></div></body></html>