<!doctype html><html itemscope itemtype=http://schema.org/WebPage lang=en class=no-js><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Performance | etcd</title>
<meta name=description content="Understanding performance: latency & throughput"><meta property="og:url" content="https://etcd.io/docs/v3.5/op-guide/performance/"><meta property="og:site_name" content="etcd"><meta property="og:title" content="Performance"><meta property="og:description" content="Understanding performance: latency & throughput"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="docs"><meta property="article:modified_time" content="2021-06-14T17:16:50+00:00"><meta itemprop=name content="Performance"><meta itemprop=description content="Understanding performance: latency & throughput"><meta itemprop=dateModified content="2021-06-14T17:16:50+00:00"><meta itemprop=wordCount content="725"><meta name=twitter:card content="summary"><meta name=twitter:title content="Performance"><meta name=twitter:description content="Understanding performance: latency & throughput"></head><body class=td-page><div class="container-fluid td-outer"><div class=td-main><div class="row flex-xl-nowrap"><main class="col-12 col-md-9 col-xl-8 ps-md-5" role=main><div class=td-content><h1>Performance</h1><div class=lead>Understanding performance: latency & throughput</div><h2 id=understanding-performance>Understanding performance</h2><p>etcd provides stable, sustained high performance. Two factors define performance: latency and throughput. Latency is the time taken to complete an operation. Throughput is the total operations completed within some time period. Usually average latency increases as the overall throughput increases when etcd accepts concurrent client requests. In common cloud environments, like a standard <code>n-4</code> on Google Compute Engine (GCE) or a comparable machine type on AWS, a three member etcd cluster finishes a request in less than one millisecond under light load, and can complete more than 30,000 requests per second under heavy load.</p><p>etcd uses the Raft consensus algorithm to replicate requests among members and reach agreement. Consensus performance, especially commit latency, is limited by two physical constraints: network IO latency and disk IO latency. The minimum time to finish an etcd request is the network Round Trip Time (RTT) between members, plus the time <code>fdatasync</code> requires to commit the data to permanent storage. The RTT within a datacenter may be as long as several hundred microseconds. A typical RTT within the United States is around 50ms, and can be as slow as 400ms between continents. The typical fdatasync latency for a spinning disk is about 10ms. For SSDs, the latency is often lower than 1ms. To increase throughput, etcd batches multiple requests together and submits them to Raft. This batching policy lets etcd attain high throughput despite heavy load.</p><p>There are other sub-systems which impact the overall performance of etcd. Each serialized etcd request must run through etcd’s boltdb-backed MVCC storage engine, which usually takes tens of microseconds to finish. Periodically etcd incrementally snapshots its recently applied requests, merging them back with the previous on-disk snapshot. This process may lead to a latency spike. Although this is usually not a problem on SSDs, it may double the observed latency on HDD. Likewise, inflight compactions can impact etcd’s performance. Fortunately, the impact is often insignificant since the compaction is staggered so it does not compete for resources with regular requests. The RPC system, gRPC, gives etcd a well-defined, extensible API, but it also introduces additional latency, especially for local reads.</p><h2 id=benchmarks>Benchmarks</h2><p>Benchmarking etcd performance can be done with the <a href=https://github.com/etcd-io/etcd/tree/master/tools/benchmark target=_blank rel=noopener>benchmark</a> CLI tool included with etcd.</p><p>For some baseline performance numbers, we consider a three member etcd cluster with the following hardware configuration:</p><ul><li>Google Cloud Compute Engine</li><li>3 machines of 8 vCPUs + 16GB Memory + 50GB SSD</li><li>1 machine(client) of 16 vCPUs + 30GB Memory + 50GB SSD</li><li>Ubuntu 17.04</li><li>etcd 3.2.0, go 1.8.3</li></ul><p>With this configuration, etcd can approximately write:</p><table><thead><tr><th style=text-align:right>Number of keys</th><th style=text-align:right>Key size in bytes</th><th style=text-align:right>Value size in bytes</th><th style=text-align:right>Number of connections</th><th style=text-align:right>Number of clients</th><th>Target etcd server</th><th style=text-align:right>Average write QPS</th><th style=text-align:right>Average latency per request</th><th style=text-align:right>Average server RSS</th></tr></thead><tbody><tr><td style=text-align:right>10,000</td><td style=text-align:right>8</td><td style=text-align:right>256</td><td style=text-align:right>1</td><td style=text-align:right>1</td><td>leader only</td><td style=text-align:right>583</td><td style=text-align:right>1.6ms</td><td style=text-align:right>48 MB</td></tr><tr><td style=text-align:right>100,000</td><td style=text-align:right>8</td><td style=text-align:right>256</td><td style=text-align:right>100</td><td style=text-align:right>1000</td><td>leader only</td><td style=text-align:right>44,341</td><td style=text-align:right>22ms</td><td style=text-align:right>124MB</td></tr><tr><td style=text-align:right>100,000</td><td style=text-align:right>8</td><td style=text-align:right>256</td><td style=text-align:right>100</td><td style=text-align:right>1000</td><td>all members</td><td style=text-align:right>50,104</td><td style=text-align:right>20ms</td><td style=text-align:right>126MB</td></tr></tbody></table><p>Sample commands are:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span><span style=color:#8f5902;font-style:italic># write to leader</span>
</span></span><span style=display:flex><span>benchmark --endpoints<span style=color:#ce5c00;font-weight:700>=</span><span style=color:#4e9a06>${</span><span style=color:#000>HOST_1</span><span style=color:#4e9a06>}</span> --target-leader --conns<span style=color:#ce5c00;font-weight:700>=</span><span style=color:#0000cf;font-weight:700>1</span> --clients<span style=color:#ce5c00;font-weight:700>=</span><span style=color:#0000cf;font-weight:700>1</span> <span style=color:#4e9a06>\
</span></span></span><span style=display:flex><span><span style=color:#4e9a06></span>    put --key-size<span style=color:#ce5c00;font-weight:700>=</span><span style=color:#0000cf;font-weight:700>8</span> --sequential-keys --total<span style=color:#ce5c00;font-weight:700>=</span><span style=color:#0000cf;font-weight:700>10000</span> --val-size<span style=color:#ce5c00;font-weight:700>=</span><span style=color:#0000cf;font-weight:700>256</span>
</span></span><span style=display:flex><span>benchmark --endpoints<span style=color:#ce5c00;font-weight:700>=</span><span style=color:#4e9a06>${</span><span style=color:#000>HOST_1</span><span style=color:#4e9a06>}</span> --target-leader  --conns<span style=color:#ce5c00;font-weight:700>=</span><span style=color:#0000cf;font-weight:700>100</span> --clients<span style=color:#ce5c00;font-weight:700>=</span><span style=color:#0000cf;font-weight:700>1000</span> <span style=color:#4e9a06>\
</span></span></span><span style=display:flex><span><span style=color:#4e9a06></span>    put --key-size<span style=color:#ce5c00;font-weight:700>=</span><span style=color:#0000cf;font-weight:700>8</span> --sequential-keys --total<span style=color:#ce5c00;font-weight:700>=</span><span style=color:#0000cf;font-weight:700>100000</span> --val-size<span style=color:#ce5c00;font-weight:700>=</span><span style=color:#0000cf;font-weight:700>256</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic># write to all members</span>
</span></span><span style=display:flex><span>benchmark --endpoints<span style=color:#ce5c00;font-weight:700>=</span><span style=color:#4e9a06>${</span><span style=color:#000>HOST_1</span><span style=color:#4e9a06>}</span>,<span style=color:#4e9a06>${</span><span style=color:#000>HOST_2</span><span style=color:#4e9a06>}</span>,<span style=color:#4e9a06>${</span><span style=color:#000>HOST_3</span><span style=color:#4e9a06>}</span> --conns<span style=color:#ce5c00;font-weight:700>=</span><span style=color:#0000cf;font-weight:700>100</span> --clients<span style=color:#ce5c00;font-weight:700>=</span><span style=color:#0000cf;font-weight:700>1000</span> <span style=color:#4e9a06>\
</span></span></span><span style=display:flex><span><span style=color:#4e9a06></span>    put --key-size<span style=color:#ce5c00;font-weight:700>=</span><span style=color:#0000cf;font-weight:700>8</span> --sequential-keys --total<span style=color:#ce5c00;font-weight:700>=</span><span style=color:#0000cf;font-weight:700>100000</span> --val-size<span style=color:#ce5c00;font-weight:700>=</span><span style=color:#0000cf;font-weight:700>256</span>
</span></span></code></pre></div><p>Linearizable read requests go through a quorum of cluster members for consensus to fetch the most recent data. Serializable read requests are cheaper than linearizable reads since they are served by any single etcd member, instead of a quorum of members, in exchange for possibly serving stale data. etcd can read:</p><table><thead><tr><th style=text-align:right>Number of requests</th><th style=text-align:right>Key size in bytes</th><th style=text-align:right>Value size in bytes</th><th style=text-align:right>Number of connections</th><th style=text-align:right>Number of clients</th><th>Consistency</th><th style=text-align:right>Average read QPS</th><th style=text-align:right>Average latency per request</th></tr></thead><tbody><tr><td style=text-align:right>10,000</td><td style=text-align:right>8</td><td style=text-align:right>256</td><td style=text-align:right>1</td><td style=text-align:right>1</td><td>Linearizable</td><td style=text-align:right>1,353</td><td style=text-align:right>0.7ms</td></tr><tr><td style=text-align:right>10,000</td><td style=text-align:right>8</td><td style=text-align:right>256</td><td style=text-align:right>1</td><td style=text-align:right>1</td><td>Serializable</td><td style=text-align:right>2,909</td><td style=text-align:right>0.3ms</td></tr><tr><td style=text-align:right>100,000</td><td style=text-align:right>8</td><td style=text-align:right>256</td><td style=text-align:right>100</td><td style=text-align:right>1000</td><td>Linearizable</td><td style=text-align:right>141,578</td><td style=text-align:right>5.5ms</td></tr><tr><td style=text-align:right>100,000</td><td style=text-align:right>8</td><td style=text-align:right>256</td><td style=text-align:right>100</td><td style=text-align:right>1000</td><td>Serializable</td><td style=text-align:right>185,758</td><td style=text-align:right>2.2ms</td></tr></tbody></table><p>Sample commands are:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span><span style=color:#8f5902;font-style:italic># Single connection read requests</span>
</span></span><span style=display:flex><span>benchmark --endpoints<span style=color:#ce5c00;font-weight:700>=</span><span style=color:#4e9a06>${</span><span style=color:#000>HOST_1</span><span style=color:#4e9a06>}</span>,<span style=color:#4e9a06>${</span><span style=color:#000>HOST_2</span><span style=color:#4e9a06>}</span>,<span style=color:#4e9a06>${</span><span style=color:#000>HOST_3</span><span style=color:#4e9a06>}</span> --conns<span style=color:#ce5c00;font-weight:700>=</span><span style=color:#0000cf;font-weight:700>1</span> --clients<span style=color:#ce5c00;font-weight:700>=</span><span style=color:#0000cf;font-weight:700>1</span> <span style=color:#4e9a06>\
</span></span></span><span style=display:flex><span><span style=color:#4e9a06></span>    range YOUR_KEY --consistency<span style=color:#ce5c00;font-weight:700>=</span>l --total<span style=color:#ce5c00;font-weight:700>=</span><span style=color:#0000cf;font-weight:700>10000</span>
</span></span><span style=display:flex><span>benchmark --endpoints<span style=color:#ce5c00;font-weight:700>=</span><span style=color:#4e9a06>${</span><span style=color:#000>HOST_1</span><span style=color:#4e9a06>}</span>,<span style=color:#4e9a06>${</span><span style=color:#000>HOST_2</span><span style=color:#4e9a06>}</span>,<span style=color:#4e9a06>${</span><span style=color:#000>HOST_3</span><span style=color:#4e9a06>}</span> --conns<span style=color:#ce5c00;font-weight:700>=</span><span style=color:#0000cf;font-weight:700>1</span> --clients<span style=color:#ce5c00;font-weight:700>=</span><span style=color:#0000cf;font-weight:700>1</span> <span style=color:#4e9a06>\
</span></span></span><span style=display:flex><span><span style=color:#4e9a06></span>    range YOUR_KEY --consistency<span style=color:#ce5c00;font-weight:700>=</span>s --total<span style=color:#ce5c00;font-weight:700>=</span><span style=color:#0000cf;font-weight:700>10000</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic># Many concurrent read requests</span>
</span></span><span style=display:flex><span>benchmark --endpoints<span style=color:#ce5c00;font-weight:700>=</span><span style=color:#4e9a06>${</span><span style=color:#000>HOST_1</span><span style=color:#4e9a06>}</span>,<span style=color:#4e9a06>${</span><span style=color:#000>HOST_2</span><span style=color:#4e9a06>}</span>,<span style=color:#4e9a06>${</span><span style=color:#000>HOST_3</span><span style=color:#4e9a06>}</span> --conns<span style=color:#ce5c00;font-weight:700>=</span><span style=color:#0000cf;font-weight:700>100</span> --clients<span style=color:#ce5c00;font-weight:700>=</span><span style=color:#0000cf;font-weight:700>1000</span> <span style=color:#4e9a06>\
</span></span></span><span style=display:flex><span><span style=color:#4e9a06></span>    range YOUR_KEY --consistency<span style=color:#ce5c00;font-weight:700>=</span>l --total<span style=color:#ce5c00;font-weight:700>=</span><span style=color:#0000cf;font-weight:700>100000</span>
</span></span><span style=display:flex><span>benchmark --endpoints<span style=color:#ce5c00;font-weight:700>=</span><span style=color:#4e9a06>${</span><span style=color:#000>HOST_1</span><span style=color:#4e9a06>}</span>,<span style=color:#4e9a06>${</span><span style=color:#000>HOST_2</span><span style=color:#4e9a06>}</span>,<span style=color:#4e9a06>${</span><span style=color:#000>HOST_3</span><span style=color:#4e9a06>}</span> --conns<span style=color:#ce5c00;font-weight:700>=</span><span style=color:#0000cf;font-weight:700>100</span> --clients<span style=color:#ce5c00;font-weight:700>=</span><span style=color:#0000cf;font-weight:700>1000</span> <span style=color:#4e9a06>\
</span></span></span><span style=display:flex><span><span style=color:#4e9a06></span>    range YOUR_KEY --consistency<span style=color:#ce5c00;font-weight:700>=</span>s --total<span style=color:#ce5c00;font-weight:700>=</span><span style=color:#0000cf;font-weight:700>100000</span>
</span></span></code></pre></div><p>We encourage running the benchmark test when setting up an etcd cluster for the first time in a new environment to ensure the cluster achieves adequate performance; cluster latency and throughput can be sensitive to minor environment differences.</p><div class=d-print-none><h2 class=feedback--title>Feedback</h2><p class=feedback--question>Was this page helpful?</p><button class="btn btn-primary mb-4 feedback--answer feedback--answer-yes">Yes</button>
<button class="btn btn-primary mb-4 feedback--answer feedback--answer-no">No</button><p class="feedback--response feedback--response-yes">Glad to hear it! Please <a href=https://github.com/etcd-io/website/issues/new>tell us how we can improve</a>.</p><p class="feedback--response feedback--response-no">Sorry to hear that. Please <a href=https://github.com/etcd-io/website/issues/new>tell us how we can improve</a>.</p></div><br><div class=td-page-meta__lastmod>Last modified June 14, 2021: <a href=https://github.com/etcd-io/website/commit/138926b5de44b5116fdbe63830eeaf73596e4c2c>Renaming content/en/next folder to content/en/v3.5. Updating redirects, links, and config as needed. (#363) (138926b)</a></div></div></main></div></div></div></body></html>