<!doctype html><html itemscope itemtype=http://schema.org/WebPage lang=en class=no-js><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Interacting with etcd | etcd</title>
<meta name=description content="etcdctl: a command line tool for interacting with the etcd server"><meta property="og:url" content="https://etcd.io/docs/v3.5/dev-guide/interacting_v3/"><meta property="og:site_name" content="etcd"><meta property="og:title" content="Interacting with etcd"><meta property="og:description" content="etcdctl: a command line tool for interacting with the etcd server"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="docs"><meta property="article:modified_time" content="2021-06-14T17:16:50+00:00"><meta itemprop=name content="Interacting with etcd"><meta itemprop=description content="etcdctl: a command line tool for interacting with the etcd server"><meta itemprop=dateModified content="2021-06-14T17:16:50+00:00"><meta itemprop=wordCount content="2198"><meta name=twitter:card content="summary"><meta name=twitter:title content="Interacting with etcd"><meta name=twitter:description content="etcdctl: a command line tool for interacting with the etcd server"></head><body class=td-page><div class="container-fluid td-outer"><div class=td-main><div class="row flex-xl-nowrap"><main class="col-12 col-md-9 col-xl-8 ps-md-5" role=main><div class=td-content><h1>Interacting with etcd</h1><div class=lead>etcdctl: a command line tool for interacting with the etcd server</div><p>Users mostly interact with etcd by putting or getting the value of a key. This section describes how to do that by using etcdctl, a command line tool for interacting with etcd server. The concepts described here should apply to the gRPC APIs or client library APIs.</p><p>The API version used by etcdctl to speak to etcd may be set to version <code>2</code> or <code>3</code> via the <code>ETCDCTL_API</code> environment variable. By default, etcdctl on master (3.4) uses the v3 API and earlier versions (3.3 and earlier) default to the v2 API.</p><p>Note that any key that was created using the v2 API will not be able to be queried via the v3 API. A v3 API <code>etcdctl get</code> of a v2 key will exit with 0 and no key data, this is the expected behaviour.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#204a87>export</span> <span style=color:#000>ETCDCTL_API</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#0000cf;font-weight:700>3</span>
</span></span></code></pre></div><h2 id=find-versions>Find versions</h2><p>etcdctl version and Server API version can be useful in finding the appropriate commands to be used for performing various operations on etcd.</p><p>Here is the command to find the versions:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ etcdctl version
</span></span><span style=display:flex><span>etcdctl version: 3.1.0-alpha.0+git
</span></span><span style=display:flex><span>API version: 3.1
</span></span></code></pre></div><h2 id=write-a-key>Write a key</h2><p>Applications store keys into the etcd cluster by writing to keys. Every stored key is replicated to all etcd cluster members through the Raft protocol to achieve consistency and reliability.</p><p>Here is the command to set the value of key <code>foo</code> to <code>bar</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ etcdctl put foo bar
</span></span><span style=display:flex><span>OK
</span></span></code></pre></div><p>Also a key can be set for a specified interval of time by attaching lease to it.</p><p>Here is the command to set the value of key <code>foo1</code> to <code>bar1</code> for 10s.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ etcdctl put foo1 bar1 --lease<span style=color:#ce5c00;font-weight:700>=</span>1234abcd
</span></span><span style=display:flex><span>OK
</span></span></code></pre></div><p>Note: The lease id <code>1234abcd</code> in the above command refers to id returned on creating the lease of 10s. This id can then be attached to the key.</p><h2 id=read-keys>Read keys</h2><p>Applications can read values of keys from an etcd cluster. Queries may read a single key, or a range of keys.</p><p>Suppose the etcd cluster has stored the following keys:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#000>foo</span> <span style=color:#ce5c00;font-weight:700>=</span> bar
</span></span><span style=display:flex><span><span style=color:#000>foo1</span> <span style=color:#ce5c00;font-weight:700>=</span> bar1
</span></span><span style=display:flex><span><span style=color:#000>foo2</span> <span style=color:#ce5c00;font-weight:700>=</span> bar2
</span></span><span style=display:flex><span><span style=color:#000>foo3</span> <span style=color:#ce5c00;font-weight:700>=</span> bar3
</span></span></code></pre></div><p>Here is the command to read the value of key <code>foo</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ etcdctl get foo
</span></span><span style=display:flex><span>foo
</span></span><span style=display:flex><span>bar
</span></span></code></pre></div><p>Here is the command to read the value of key <code>foo</code> in hex format:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ etcdctl get foo --hex
</span></span><span style=display:flex><span><span style=color:#4e9a06>\x</span>66<span style=color:#4e9a06>\x</span>6f<span style=color:#4e9a06>\x</span>6f          <span style=color:#8f5902;font-style:italic># Key</span>
</span></span><span style=display:flex><span><span style=color:#4e9a06>\x</span>62<span style=color:#4e9a06>\x</span>61<span style=color:#4e9a06>\x</span><span style=color:#0000cf;font-weight:700>72</span>          <span style=color:#8f5902;font-style:italic># Value</span>
</span></span></code></pre></div><p>Here is the command to read only the value of key <code>foo</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ etcdctl get foo --print-value-only
</span></span><span style=display:flex><span>bar
</span></span></code></pre></div><p>Here is the command to range over the keys from <code>foo</code> to <code>foo3</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ etcdctl get foo foo3
</span></span><span style=display:flex><span>foo
</span></span><span style=display:flex><span>bar
</span></span><span style=display:flex><span>foo1
</span></span><span style=display:flex><span>bar1
</span></span><span style=display:flex><span>foo2
</span></span><span style=display:flex><span>bar2
</span></span></code></pre></div><p>Note that <code>foo3</code> is excluded since the range is over the half-open interval <code>[foo, foo3)</code>, excluding <code>foo3</code>.</p><p>Here is the command to range over all keys prefixed with <code>foo</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ etcdctl get --prefix foo
</span></span><span style=display:flex><span>foo
</span></span><span style=display:flex><span>bar
</span></span><span style=display:flex><span>foo1
</span></span><span style=display:flex><span>bar1
</span></span><span style=display:flex><span>foo2
</span></span><span style=display:flex><span>bar2
</span></span><span style=display:flex><span>foo3
</span></span><span style=display:flex><span>bar3
</span></span></code></pre></div><p>Here is the command to range over all keys prefixed with <code>foo</code>, limiting the number of results to 2:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ etcdctl get --prefix --limit<span style=color:#ce5c00;font-weight:700>=</span><span style=color:#0000cf;font-weight:700>2</span> foo
</span></span><span style=display:flex><span>foo
</span></span><span style=display:flex><span>bar
</span></span><span style=display:flex><span>foo1
</span></span><span style=display:flex><span>bar1
</span></span></code></pre></div><h2 id=read-past-version-of-keys>Read past version of keys</h2><p>Applications may want to read superseded versions of a key. For example, an application may wish to roll back to an old configuration by accessing an earlier version of a key. Alternatively, an application may want a consistent view over multiple keys through multiple requests by accessing key history.
Since every modification to the etcd cluster key-value store increments the global revision of an etcd cluster, an application can read superseded keys by providing an older etcd revision.</p><p>Suppose an etcd cluster already has the following keys:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#000>foo</span> <span style=color:#ce5c00;font-weight:700>=</span> bar         <span style=color:#8f5902;font-style:italic># revision = 2</span>
</span></span><span style=display:flex><span><span style=color:#000>foo1</span> <span style=color:#ce5c00;font-weight:700>=</span> bar1       <span style=color:#8f5902;font-style:italic># revision = 3</span>
</span></span><span style=display:flex><span><span style=color:#000>foo</span> <span style=color:#ce5c00;font-weight:700>=</span> bar_new     <span style=color:#8f5902;font-style:italic># revision = 4</span>
</span></span><span style=display:flex><span><span style=color:#000>foo1</span> <span style=color:#ce5c00;font-weight:700>=</span> bar1_new   <span style=color:#8f5902;font-style:italic># revision = 5</span>
</span></span></code></pre></div><p>Here are an example to access the past versions of keys:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ etcdctl get --prefix foo <span style=color:#8f5902;font-style:italic># access the most recent versions of keys</span>
</span></span><span style=display:flex><span>foo
</span></span><span style=display:flex><span>bar_new
</span></span><span style=display:flex><span>foo1
</span></span><span style=display:flex><span>bar1_new
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>$ etcdctl get --prefix --rev<span style=color:#ce5c00;font-weight:700>=</span><span style=color:#0000cf;font-weight:700>4</span> foo <span style=color:#8f5902;font-style:italic># access the versions of keys at revision 4</span>
</span></span><span style=display:flex><span>foo
</span></span><span style=display:flex><span>bar_new
</span></span><span style=display:flex><span>foo1
</span></span><span style=display:flex><span>bar1
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>$ etcdctl get --prefix --rev<span style=color:#ce5c00;font-weight:700>=</span><span style=color:#0000cf;font-weight:700>3</span> foo <span style=color:#8f5902;font-style:italic># access the versions of keys at revision 3</span>
</span></span><span style=display:flex><span>foo
</span></span><span style=display:flex><span>bar
</span></span><span style=display:flex><span>foo1
</span></span><span style=display:flex><span>bar1
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>$ etcdctl get --prefix --rev<span style=color:#ce5c00;font-weight:700>=</span><span style=color:#0000cf;font-weight:700>2</span> foo <span style=color:#8f5902;font-style:italic># access the versions of keys at revision 2</span>
</span></span><span style=display:flex><span>foo
</span></span><span style=display:flex><span>bar
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>$ etcdctl get --prefix --rev<span style=color:#ce5c00;font-weight:700>=</span><span style=color:#0000cf;font-weight:700>1</span> foo <span style=color:#8f5902;font-style:italic># access the versions of keys at revision 1</span>
</span></span></code></pre></div><h2 id=read-keys-which-are-greater-than-or-equal-to-the-byte-value-of-the-specified-key>Read keys which are greater than or equal to the byte value of the specified key</h2><p>Applications may want to read keys which are greater than or equal to the byte value of the specified key.</p><p>Suppose an etcd cluster already has the following keys:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#000>a</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#0000cf;font-weight:700>123</span>
</span></span><span style=display:flex><span><span style=color:#000>b</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#0000cf;font-weight:700>456</span>
</span></span><span style=display:flex><span><span style=color:#000>z</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#0000cf;font-weight:700>789</span>
</span></span></code></pre></div><p>Here is the command to read keys which are greater than or equal to the byte value of key <code>b</code> :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ etcdctl get --from-key b
</span></span><span style=display:flex><span>b
</span></span><span style=display:flex><span><span style=color:#0000cf;font-weight:700>456</span>
</span></span><span style=display:flex><span>z
</span></span><span style=display:flex><span><span style=color:#0000cf;font-weight:700>789</span>
</span></span></code></pre></div><h2 id=delete-keys>Delete keys</h2><p>Applications can delete a key or a range of keys from an etcd cluster.</p><p>Suppose an etcd cluster already has the following keys:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#000>foo</span> <span style=color:#ce5c00;font-weight:700>=</span> bar
</span></span><span style=display:flex><span><span style=color:#000>foo1</span> <span style=color:#ce5c00;font-weight:700>=</span> bar1
</span></span><span style=display:flex><span><span style=color:#000>foo3</span> <span style=color:#ce5c00;font-weight:700>=</span> bar3
</span></span><span style=display:flex><span><span style=color:#000>zoo</span> <span style=color:#ce5c00;font-weight:700>=</span> val
</span></span><span style=display:flex><span><span style=color:#000>zoo1</span> <span style=color:#ce5c00;font-weight:700>=</span> val1
</span></span><span style=display:flex><span><span style=color:#000>zoo2</span> <span style=color:#ce5c00;font-weight:700>=</span> val2
</span></span><span style=display:flex><span><span style=color:#000>a</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#0000cf;font-weight:700>123</span>
</span></span><span style=display:flex><span><span style=color:#000>b</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#0000cf;font-weight:700>456</span>
</span></span><span style=display:flex><span><span style=color:#000>z</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#0000cf;font-weight:700>789</span>
</span></span></code></pre></div><p>Here is the command to delete key <code>foo</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ etcdctl del foo
</span></span><span style=display:flex><span><span style=color:#0000cf;font-weight:700>1</span> <span style=color:#8f5902;font-style:italic># one key is deleted</span>
</span></span></code></pre></div><p>Here is the command to delete keys ranging from <code>foo</code> to <code>foo9</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ etcdctl del foo foo9
</span></span><span style=display:flex><span><span style=color:#0000cf;font-weight:700>2</span> <span style=color:#8f5902;font-style:italic># two keys are deleted</span>
</span></span></code></pre></div><p>Here is the command to delete key <code>zoo</code> with the deleted key value pair returned:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ etcdctl del --prev-kv zoo
</span></span><span style=display:flex><span><span style=color:#0000cf;font-weight:700>1</span>   <span style=color:#8f5902;font-style:italic># one key is deleted</span>
</span></span><span style=display:flex><span>zoo <span style=color:#8f5902;font-style:italic># deleted key</span>
</span></span><span style=display:flex><span>val <span style=color:#8f5902;font-style:italic># the value of the deleted key</span>
</span></span></code></pre></div><p>Here is the command to delete keys having prefix as <code>zoo</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ etcdctl del --prefix zoo
</span></span><span style=display:flex><span><span style=color:#0000cf;font-weight:700>2</span> <span style=color:#8f5902;font-style:italic># two keys are deleted</span>
</span></span></code></pre></div><p>Here is the command to delete keys which are greater than or equal to the byte value of key <code>b</code> :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ etcdctl del --from-key b
</span></span><span style=display:flex><span><span style=color:#0000cf;font-weight:700>2</span> <span style=color:#8f5902;font-style:italic># two keys are deleted</span>
</span></span></code></pre></div><h2 id=watch-key-changes>Watch key changes</h2><p>Applications can watch on a key or a range of keys to monitor for any updates.</p><p>Here is the command to watch on key <code>foo</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ etcdctl watch foo
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic># in another terminal: etcdctl put foo bar</span>
</span></span><span style=display:flex><span>PUT
</span></span><span style=display:flex><span>foo
</span></span><span style=display:flex><span>bar
</span></span></code></pre></div><p>Here is the command to watch on key <code>foo</code> in hex format:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ etcdctl watch foo --hex
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic># in another terminal: etcdctl put foo bar</span>
</span></span><span style=display:flex><span>PUT
</span></span><span style=display:flex><span><span style=color:#4e9a06>\x</span>66<span style=color:#4e9a06>\x</span>6f<span style=color:#4e9a06>\x</span>6f          <span style=color:#8f5902;font-style:italic># Key</span>
</span></span><span style=display:flex><span><span style=color:#4e9a06>\x</span>62<span style=color:#4e9a06>\x</span>61<span style=color:#4e9a06>\x</span><span style=color:#0000cf;font-weight:700>72</span>          <span style=color:#8f5902;font-style:italic># Value</span>
</span></span></code></pre></div><p>Here is the command to watch on a range key from <code>foo</code> to <code>foo9</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ etcdctl watch foo foo9
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic># in another terminal: etcdctl put foo bar</span>
</span></span><span style=display:flex><span>PUT
</span></span><span style=display:flex><span>foo
</span></span><span style=display:flex><span>bar
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic># in another terminal: etcdctl put foo1 bar1</span>
</span></span><span style=display:flex><span>PUT
</span></span><span style=display:flex><span>foo1
</span></span><span style=display:flex><span>bar1
</span></span></code></pre></div><p>Here is the command to watch on keys having prefix <code>foo</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ etcdctl watch --prefix foo
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic># in another terminal: etcdctl put foo bar</span>
</span></span><span style=display:flex><span>PUT
</span></span><span style=display:flex><span>foo
</span></span><span style=display:flex><span>bar
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic># in another terminal: etcdctl put fooz1 barz1</span>
</span></span><span style=display:flex><span>PUT
</span></span><span style=display:flex><span>fooz1
</span></span><span style=display:flex><span>barz1
</span></span></code></pre></div><p>Here is the command to watch on multiple keys <code>foo</code> and <code>zoo</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ etcdctl watch -i
</span></span><span style=display:flex><span>$ watch foo
</span></span><span style=display:flex><span>$ watch zoo
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic># in another terminal: etcdctl put foo bar</span>
</span></span><span style=display:flex><span>PUT
</span></span><span style=display:flex><span>foo
</span></span><span style=display:flex><span>bar
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic># in another terminal: etcdctl put zoo val</span>
</span></span><span style=display:flex><span>PUT
</span></span><span style=display:flex><span>zoo
</span></span><span style=display:flex><span>val
</span></span></code></pre></div><h2 id=watch-historical-changes-of-keys>Watch historical changes of keys</h2><p>Applications may want to watch for historical changes of keys in etcd. For example, an application may wish to receive all the modifications of a key; if the application stays connected to etcd, then <code>watch</code> is good enough. However, if the application or etcd fails, a change may happen during the failure, and the application will not receive the update in real time. To guarantee the update is delivered, the application must be able to watch for historical changes to keys. To do this, an application can specify a historical revision on a watch, just like reading past version of keys.</p><p>Suppose we finished the following sequence of operations:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ etcdctl put foo bar         <span style=color:#8f5902;font-style:italic># revision = 2</span>
</span></span><span style=display:flex><span>OK
</span></span><span style=display:flex><span>$ etcdctl put foo1 bar1       <span style=color:#8f5902;font-style:italic># revision = 3</span>
</span></span><span style=display:flex><span>OK
</span></span><span style=display:flex><span>$ etcdctl put foo bar_new     <span style=color:#8f5902;font-style:italic># revision = 4</span>
</span></span><span style=display:flex><span>OK
</span></span><span style=display:flex><span>$ etcdctl put foo1 bar1_new   <span style=color:#8f5902;font-style:italic># revision = 5</span>
</span></span><span style=display:flex><span>OK
</span></span></code></pre></div><p>Here is an example to watch the historical changes:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#8f5902;font-style:italic># watch for changes on key `foo` since revision 2</span>
</span></span><span style=display:flex><span>$ etcdctl watch --rev<span style=color:#ce5c00;font-weight:700>=</span><span style=color:#0000cf;font-weight:700>2</span> foo
</span></span><span style=display:flex><span>PUT
</span></span><span style=display:flex><span>foo
</span></span><span style=display:flex><span>bar
</span></span><span style=display:flex><span>PUT
</span></span><span style=display:flex><span>foo
</span></span><span style=display:flex><span>bar_new
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#8f5902;font-style:italic># watch for changes on key `foo` since revision 3</span>
</span></span><span style=display:flex><span>$ etcdctl watch --rev<span style=color:#ce5c00;font-weight:700>=</span><span style=color:#0000cf;font-weight:700>3</span> foo
</span></span><span style=display:flex><span>PUT
</span></span><span style=display:flex><span>foo
</span></span><span style=display:flex><span>bar_new
</span></span></code></pre></div><p>Here is an example to watch only from the last historical change:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#8f5902;font-style:italic># watch for changes on key `foo` and return last revision value along with modified value</span>
</span></span><span style=display:flex><span>$ etcdctl watch --prev-kv foo
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic># in another terminal: etcdctl put foo bar_latest</span>
</span></span><span style=display:flex><span>PUT
</span></span><span style=display:flex><span>foo         <span style=color:#8f5902;font-style:italic># key</span>
</span></span><span style=display:flex><span>bar_new     <span style=color:#8f5902;font-style:italic># last value of foo key before modification</span>
</span></span><span style=display:flex><span>foo         <span style=color:#8f5902;font-style:italic># key</span>
</span></span><span style=display:flex><span>bar_latest  <span style=color:#8f5902;font-style:italic># value of foo key after modification</span>
</span></span></code></pre></div><h2 id=watch-progress>Watch progress</h2><p>Applications may want to check the progress of a watch to determine how up-to-date the watch stream is. For example, if a watch is used to update a cache, it can be useful to know if the cache is stale compared to the revision from a quorum read.</p><p>Progress requests can be issued using the &ldquo;progress&rdquo; command in interactive watch session to ask the etcd server to send a progress notify update in the watch stream:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ etcdctl watch -i
</span></span><span style=display:flex><span>$ watch a
</span></span><span style=display:flex><span>$ progress
</span></span><span style=display:flex><span>progress notify: <span style=color:#0000cf;font-weight:700>1</span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic># in another terminal: etcdctl put x 0</span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic># in another terminal: etcdctl put y 1</span>
</span></span><span style=display:flex><span>$ progress
</span></span><span style=display:flex><span>progress notify: <span style=color:#0000cf;font-weight:700>3</span>
</span></span></code></pre></div><p>Note: The revision number in the progress notify response is the revision from the local etcd server node that the watch stream is connected to. If this node is partitioned and not part of quorum, this progress notify revision might be lower than
than the revision returned by a quorum read against a non-partitioned etcd server node.</p><h2 id=compacted-revisions>Compacted revisions</h2><p>As we mentioned, etcd keeps revisions so that applications can read past versions of keys. However, to avoid accumulating an unbounded amount of history, it is important to compact past revisions. After compacting, etcd removes historical revisions, releasing resources for future use. All superseded data with revisions before the compacted revision will be unavailable.</p><p>Here is the command to compact the revisions:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ etcdctl compact <span style=color:#0000cf;font-weight:700>5</span>
</span></span><span style=display:flex><span>compacted revision <span style=color:#0000cf;font-weight:700>5</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic># any revisions before the compacted one are not accessible</span>
</span></span><span style=display:flex><span>$ etcdctl get --rev<span style=color:#ce5c00;font-weight:700>=</span><span style=color:#0000cf;font-weight:700>4</span> foo
</span></span><span style=display:flex><span>Error:  rpc error: <span style=color:#000>code</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#0000cf;font-weight:700>11</span> <span style=color:#000>desc</span> <span style=color:#ce5c00;font-weight:700>=</span> etcdserver: mvcc: required revision has been compacted
</span></span></code></pre></div><p>Note: The current revision of etcd server can be found using get command on any key (existent or non-existent) in json format. Example is shown below for mykey which does not exist in etcd server:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ etcdctl get mykey -w<span style=color:#ce5c00;font-weight:700>=</span>json
</span></span><span style=display:flex><span><span style=color:#ce5c00;font-weight:700>{</span><span style=color:#4e9a06>&#34;header&#34;</span>:<span style=color:#ce5c00;font-weight:700>{</span><span style=color:#4e9a06>&#34;cluster_id&#34;</span>:14841639068965178418,<span style=color:#4e9a06>&#34;member_id&#34;</span>:10276657743932975437,<span style=color:#4e9a06>&#34;revision&#34;</span>:15,<span style=color:#4e9a06>&#34;raft_term&#34;</span>:4<span style=color:#ce5c00;font-weight:700>}}</span>
</span></span></code></pre></div><h2 id=grant-leases>Grant leases</h2><p>Applications can grant leases for keys from an etcd cluster. When a key is attached to a lease, its lifetime is bound to the lease&rsquo;s lifetime which in turn is governed by a time-to-live (TTL). Each lease has a minimum time-to-live (TTL) value specified by the application at grant time. The lease&rsquo;s actual TTL value is at least the minimum TTL and is chosen by the etcd cluster. Once a lease&rsquo;s TTL elapses, the lease expires and all attached keys are deleted.</p><p>Here is the command to grant a lease:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#8f5902;font-style:italic># grant a lease with 60 second TTL</span>
</span></span><span style=display:flex><span>$ etcdctl lease grant <span style=color:#0000cf;font-weight:700>60</span>
</span></span><span style=display:flex><span>lease 32695410dcc0ca06 granted with TTL<span style=color:#ce5c00;font-weight:700>(</span>60s<span style=color:#ce5c00;font-weight:700>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic># attach key foo to lease 32695410dcc0ca06</span>
</span></span><span style=display:flex><span>$ etcdctl put --lease<span style=color:#ce5c00;font-weight:700>=</span>32695410dcc0ca06 foo bar
</span></span><span style=display:flex><span>OK
</span></span></code></pre></div><h2 id=revoke-leases>Revoke leases</h2><p>Applications revoke leases by lease ID. Revoking a lease deletes all of its attached keys.</p><p>Suppose we finished the following sequence of operations:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ etcdctl lease grant <span style=color:#0000cf;font-weight:700>60</span>
</span></span><span style=display:flex><span>lease 32695410dcc0ca06 granted with TTL<span style=color:#ce5c00;font-weight:700>(</span>60s<span style=color:#ce5c00;font-weight:700>)</span>
</span></span><span style=display:flex><span>$ etcdctl put --lease<span style=color:#ce5c00;font-weight:700>=</span>32695410dcc0ca06 foo bar
</span></span><span style=display:flex><span>OK
</span></span></code></pre></div><p>Here is the command to revoke the same lease:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ etcdctl lease revoke 32695410dcc0ca06
</span></span><span style=display:flex><span>lease 32695410dcc0ca06 revoked
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>$ etcdctl get foo
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic># empty response since foo is deleted due to lease revocation</span>
</span></span></code></pre></div><h2 id=keep-leases-alive>Keep leases alive</h2><p>Applications can keep a lease alive by refreshing its TTL so it does not expire.</p><p>Suppose we finished the following sequence of operations:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ etcdctl lease grant <span style=color:#0000cf;font-weight:700>60</span>
</span></span><span style=display:flex><span>lease 32695410dcc0ca06 granted with TTL<span style=color:#ce5c00;font-weight:700>(</span>60s<span style=color:#ce5c00;font-weight:700>)</span>
</span></span></code></pre></div><p>Here is the command to keep the same lease alive:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ etcdctl lease keep-alive 32695410dcc0ca06
</span></span><span style=display:flex><span>lease 32695410dcc0ca06 keepalived with TTL<span style=color:#ce5c00;font-weight:700>(</span>60<span style=color:#ce5c00;font-weight:700>)</span>
</span></span><span style=display:flex><span>lease 32695410dcc0ca06 keepalived with TTL<span style=color:#ce5c00;font-weight:700>(</span>60<span style=color:#ce5c00;font-weight:700>)</span>
</span></span><span style=display:flex><span>lease 32695410dcc0ca06 keepalived with TTL<span style=color:#ce5c00;font-weight:700>(</span>60<span style=color:#ce5c00;font-weight:700>)</span>
</span></span><span style=display:flex><span>...
</span></span></code></pre></div><h2 id=get-lease-information>Get lease information</h2><p>Applications may want to know about lease information, so that they can be renewed or to check if the lease still exists or it has expired. Applications may also want to know the keys to which a particular lease is attached.</p><p>Suppose we finished the following sequence of operations:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#8f5902;font-style:italic># grant a lease with 500 second TTL</span>
</span></span><span style=display:flex><span>$ etcdctl lease grant <span style=color:#0000cf;font-weight:700>500</span>
</span></span><span style=display:flex><span>lease 694d5765fc71500b granted with TTL<span style=color:#ce5c00;font-weight:700>(</span>500s<span style=color:#ce5c00;font-weight:700>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic># attach key zoo1 to lease 694d5765fc71500b</span>
</span></span><span style=display:flex><span>$ etcdctl put zoo1 val1 --lease<span style=color:#ce5c00;font-weight:700>=</span>694d5765fc71500b
</span></span><span style=display:flex><span>OK
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic># attach key zoo2 to lease 694d5765fc71500b</span>
</span></span><span style=display:flex><span>$ etcdctl put zoo2 val2 --lease<span style=color:#ce5c00;font-weight:700>=</span>694d5765fc71500b
</span></span><span style=display:flex><span>OK
</span></span></code></pre></div><p>Here is the command to get information about the lease:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ etcdctl lease timetolive 694d5765fc71500b
</span></span><span style=display:flex><span>lease 694d5765fc71500b granted with TTL<span style=color:#ce5c00;font-weight:700>(</span>500s<span style=color:#ce5c00;font-weight:700>)</span>, remaining<span style=color:#ce5c00;font-weight:700>(</span>258s<span style=color:#ce5c00;font-weight:700>)</span>
</span></span></code></pre></div><p>Here is the command to get information about the lease along with the keys attached with the lease:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ etcdctl lease timetolive --keys 694d5765fc71500b
</span></span><span style=display:flex><span>lease 694d5765fc71500b granted with TTL<span style=color:#ce5c00;font-weight:700>(</span>500s<span style=color:#ce5c00;font-weight:700>)</span>, remaining<span style=color:#ce5c00;font-weight:700>(</span>132s<span style=color:#ce5c00;font-weight:700>)</span>, attached keys<span style=color:#ce5c00;font-weight:700>([</span>zoo2 zoo1<span style=color:#ce5c00;font-weight:700>])</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic># if the lease has expired or does not exist it will give the below response:</span>
</span></span><span style=display:flex><span>Error:  etcdserver: requested lease not found
</span></span></code></pre></div><div class=d-print-none><h2 class=feedback--title>Feedback</h2><p class=feedback--question>Was this page helpful?</p><button class="btn btn-primary mb-4 feedback--answer feedback--answer-yes">Yes</button>
<button class="btn btn-primary mb-4 feedback--answer feedback--answer-no">No</button><p class="feedback--response feedback--response-yes">Glad to hear it! Please <a href=https://github.com/etcd-io/website/issues/new>tell us how we can improve</a>.</p><p class="feedback--response feedback--response-no">Sorry to hear that. Please <a href=https://github.com/etcd-io/website/issues/new>tell us how we can improve</a>.</p></div><br><div class=td-page-meta__lastmod>Last modified June 14, 2021: <a href=https://github.com/etcd-io/website/commit/138926b5de44b5116fdbe63830eeaf73596e4c2c>Renaming content/en/next folder to content/en/v3.5. Updating redirects, links, and config as needed. (#363) (138926b)</a></div></div></main></div></div></div></body></html>