<!doctype html><html itemscope itemtype=http://schema.org/WebPage lang=en class=no-js><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Maintenance | etcd</title>
<meta name=description content="Periodic etcd cluster maintenance guide"><meta property="og:url" content="https://etcd.io/docs/v3.5/op-guide/maintenance/"><meta property="og:site_name" content="etcd"><meta property="og:title" content="Maintenance"><meta property="og:description" content="Periodic etcd cluster maintenance guide"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="docs"><meta property="article:modified_time" content="2024-08-17T15:55:11+08:00"><meta itemprop=name content="Maintenance"><meta itemprop=description content="Periodic etcd cluster maintenance guide"><meta itemprop=dateModified content="2024-08-17T15:55:11+08:00"><meta itemprop=wordCount content="1971"><meta name=twitter:card content="summary"><meta name=twitter:title content="Maintenance"><meta name=twitter:description content="Periodic etcd cluster maintenance guide"></head><body class=td-page><div class="container-fluid td-outer"><div class=td-main><div class="row flex-xl-nowrap"><main class="col-12 col-md-9 col-xl-8 ps-md-5" role=main><div class=td-content><h1>Maintenance</h1><div class=lead>Periodic etcd cluster maintenance guide</div><h2 id=overview>Overview</h2><p>An etcd cluster needs periodic maintenance to remain reliable. Depending on an etcd application&rsquo;s needs, this maintenance can usually be automated and performed without downtime or significantly degraded performance.</p><p>All etcd maintenance manages storage resources consumed by the etcd keyspace. Failure to adequately control the keyspace size is guarded by storage space quotas; if an etcd member runs low on space, a quota will trigger cluster-wide alarms which will put the system into a limited-operation maintenance mode. To avoid running out of space for writes to the keyspace, the etcd keyspace history must be compacted. Storage space itself may be reclaimed by defragmenting etcd members. Finally, periodic snapshot backups of etcd member state makes it possible to recover any unintended logical data loss or corruption caused by operational error.</p><h2 id=raft-log-retention>Raft log retention</h2><p><code>etcd --snapshot-count</code> configures the number of applied Raft entries to hold in-memory before compaction. When <code>--snapshot-count</code> reaches, server first persists snapshot data onto disk, and then truncates old entries. When a slow follower requests logs before a compacted index, leader sends the snapshot forcing the follower to overwrite its state.</p><p>Higher <code>--snapshot-count</code> holds more Raft entries in memory until snapshot, thus causing <a href=https://github.com/kubernetes/kubernetes/issues/60589#issuecomment-371977156 target=_blank rel=noopener>recurrent higher memory usage</a>. Since leader retains latest Raft entries for longer, a slow follower has more time to catch up before leader snapshot. <code>--snapshot-count</code> is a tradeoff between higher memory usage and better availabilities of slow followers.</p><p>Since v3.2, the default value of <code>--snapshot-count</code> has <a href=https://github.com/etcd-io/etcd/pull/7160 target=_blank rel=noopener>changed from from 10,000 to 100,000</a>.</p><p>In performance-wise, <code>--snapshot-count</code> greater than 100,000 may impact the write throughput. Higher number of in-memory objects can slow down <a href=https://golang.org/src/runtime/mgc.go target=_blank rel=noopener>Go GC mark phase <code>runtime.scanobject</code></a>, and infrequent memory reclamation makes allocation slow. Performance varies depending on the workloads and system environments. However, in general, too frequent compaction affects cluster availabilities and write throughputs. Too infrequent compaction is also harmful placing too much pressure on Go garbage collector. See <a href=https://www.slideshare.net/mitakeh/understanding-performance-aspects-of-etcd-and-raft target=_blank rel=noopener>https://www.slideshare.net/mitakeh/understanding-performance-aspects-of-etcd-and-raft</a> for more research results.</p><h2 id=history-compaction-v3-api-key-value-database>History compaction: v3 API Key-Value Database</h2><p>Since etcd keeps an exact history of its keyspace, this history should be periodically compacted to avoid performance degradation and eventual storage space exhaustion. Compacting the keyspace history drops all information about keys superseded prior to a given keyspace revision. The space used by these keys then becomes available for additional writes to the keyspace.</p><p>The keyspace can be compacted automatically with <code>etcd</code>&rsquo;s time windowed history retention policy, or manually with <code>etcdctl</code>. The <code>etcdctl</code> method provides fine-grained control over the compacting process whereas automatic compacting fits applications that only need key history for some length of time.</p><p>An <code>etcdctl</code> initiated compaction works as follows:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span><span style=color:#8f5902;font-style:italic># compact up to revision 3</span>
</span></span><span style=display:flex><span>$ etcdctl compact <span style=color:#0000cf;font-weight:700>3</span>
</span></span></code></pre></div><p>Revisions prior to the compaction revision become inaccessible:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>$ etcdctl get --rev<span style=color:#ce5c00;font-weight:700>=</span><span style=color:#0000cf;font-weight:700>2</span> somekey
</span></span><span style=display:flex><span>Error:  rpc error: <span style=color:#000>code</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#0000cf;font-weight:700>11</span> <span style=color:#000>desc</span> <span style=color:#ce5c00;font-weight:700>=</span> etcdserver: mvcc: required revision has been compacted
</span></span></code></pre></div><h3 id=auto-compaction>Auto Compaction</h3><p><code>etcd</code> can be set to automatically compact the keyspace with the <code>--auto-compaction-*</code> option with a period of hours:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span><span style=color:#8f5902;font-style:italic># keep one hour of history</span>
</span></span><span style=display:flex><span>$ etcd --auto-compaction-retention<span style=color:#ce5c00;font-weight:700>=</span><span style=color:#0000cf;font-weight:700>1</span>
</span></span></code></pre></div><p><a href=https://github.com/etcd-io/etcd/blob/master/CHANGELOG-3.0.md target=_blank rel=noopener>v3.0.0</a> and <a href=https://github.com/etcd-io/etcd/blob/master/CHANGELOG-3.1.md target=_blank rel=noopener>v3.1.0</a> with <code>--auto-compaction-retention=10</code> run periodic compaction on v3 key-value store for every 10-hour. Compactor only supports periodic compaction. Compactor records latest revisions every 5-minute, until it reaches the first compaction period (e.g. 10-hour). In order to retain key-value history of last compaction period, it uses the last revision that was fetched before compaction period, from the revision records that were collected every 5-minute. When <code>--auto-compaction-retention=10</code>, compactor uses revision 100 for compact revision where revision 100 is the latest revision fetched from 10 hours ago. If compaction succeeds or requested revision has already been compacted, it resets period timer and starts over with new historical revision records (e.g. restart revision collect and compact for the next 10-hour period). If compaction fails, it retries in 5 minutes.</p><p><a href=https://github.com/etcd-io/etcd/blob/master/CHANGELOG-3.2.md target=_blank rel=noopener>v3.2.0</a> compactor runs <a href=https://github.com/etcd-io/etcd/pull/7875 target=_blank rel=noopener>every hour</a>. Compactor only supports periodic compaction. Compactor continues to record latest revisions every 5-minute. For every hour, it uses the last revision that was fetched before compaction period, from the revision records that were collected every 5-minute. That is, for every hour, compactor discards historical data created before compaction period. The retention window of compaction period moves to next hour. For instance, when hourly writes are 100 and <code>--auto-compaction-retention=10</code>, v3.1 compacts revision 1000, 2000, and 3000 for every 10-hour, while v3.2.x, v3.3.0, v3.3.1, and v3.3.2 compact revision 1000, 1100, and 1200 for every 1-hour. If compaction succeeds or requested revision has already been compacted, it resets period timer and removes used compacted revision from historical revision records (e.g. start next revision collect and compaction from previously collected revisions). If compaction fails, it retries in 5 minutes.</p><p>In <a href=https://github.com/etcd-io/etcd/blob/master/CHANGELOG-3.3.md target=_blank rel=noopener>v3.3.0</a>, <a href=https://github.com/etcd-io/etcd/blob/master/CHANGELOG-3.3.md target=_blank rel=noopener>v3.3.1</a>, and <a href=https://github.com/etcd-io/etcd/blob/master/CHANGELOG-3.3.md target=_blank rel=noopener>v3.3.2</a>, <code>--auto-compaction-mode=revision --auto-compaction-retention=1000</code> automatically <code>Compact</code> on <code>"latest revision" - 1000</code> every 5-minute (when latest revision is 30000, compact on revision 29000). For instance, <code>--auto-compaction-mode=periodic --auto-compaction-retention=72h</code> automatically <code>Compact</code> with 72-hour retention window, for every 7.2-hour. For instance, <code>--auto-compaction-mode=periodic --auto-compaction-retention=30m</code> automatically <code>Compact</code> with 30-minute retention window, for every 3-minute. Periodic compactor continues to record latest revisions for every 1/10 of given compaction period (e.g. 1-hour when <code>--auto-compaction-mode=periodic --auto-compaction-retention=10h</code>). For every 1/10 of given compaction period, compactor uses the last revision that was fetched before compaction period, to discard historical data. The retention window of compaction period moves for every 1/10 of given compaction period. For instance, when hourly writes are 100 and <code>--auto-compaction-retention=10</code>, v3.1 compacts revision 1000, 2000, and 3000 for every 10-hour, while v3.2.x, v3.3.0, v3.3.1, and v3.3.2 compact revision 1000, 1100, and 1200 for every 1-hour. Furthermore, when writes per minute are 1000, v3.3.0, v3.3.1, and v3.3.2 with <code>--auto-compaction-mode=periodic --auto-compaction-retention=30m</code> compact revision 30000, 33000, and 36000, for every 3-minute with more finer granularity.</p><p>When <code>--auto-compaction-retention=10h</code>, etcd first waits 10-hour for the first compaction, and then does compaction every hour (1/10 of 10-hour) afterwards like this:</p><pre tabindex=0><code>0Hr  (rev = 1)
1hr  (rev = 10)
...
8hr  (rev = 80)
9hr  (rev = 90)
10hr (rev = 100, Compact(1))
11hr (rev = 110, Compact(10))
...
</code></pre><p>Whether compaction succeeds or not, this process repeats for every 1/10 of given compaction period. If compaction succeeds, it just removes compacted revision from historical revision records.</p><p>In <a href=https://github.com/etcd-io/etcd/blob/master/CHANGELOG-3.3.md target=_blank rel=noopener>v3.3.3</a>, <code>--auto-compaction-mode=revision --auto-compaction-retention=1000</code> automatically <code>Compact</code> on <code>"latest revision" - 1000</code> every 5-minute (when latest revision is 30000, compact on revision 29000). Previously, <code>--auto-compaction-mode=periodic --auto-compaction-retention=72h</code> automatically <code>Compact</code> with 72-hour retention window for every 7.2-hour. <strong>Now, <code>Compact</code> happens, for every 1-hour but still with 72-hour retention window.</strong> Previously, <code>--auto-compaction-mode=periodic --auto-compaction-retention=30m</code> automatically <code>Compact</code> with 30-minute retention window for every 3-minute. <strong>Now, <code>Compact</code> happens, for every 30-minute but still with 30-minute retention window.</strong> Periodic compactor keeps recording latest revisions for every compaction period when given period is less than 1-hour, or for every 1-hour when given compaction period is greater than 1-hour (e.g. 1-hour when <code>--auto-compaction-mode=periodic --auto-compaction-retention=24h</code>). For every compaction period or 1-hour, compactor uses the last revision that was fetched before compaction period, to discard historical data. The retention window of compaction period moves for every given compaction period or hour. For instance, when hourly writes are 100 and <code>--auto-compaction-mode=periodic --auto-compaction-retention=24h</code>, <code>v3.2.x</code>, <code>v3.3.0</code>, <code>v3.3.1</code>, and <code>v3.3.2</code> compact revision 2400, 2640, and 2880 for every 2.4-hour, while <code>v3.3.3</code> <em>or later</em> compacts revision 2400, 2500, 2600 for every 1-hour. Furthermore, when <code>--auto-compaction-mode=periodic --auto-compaction-retention=30m</code> and writes per minute are about 1000, <code>v3.3.0</code>, <code>v3.3.1</code>, and <code>v3.3.2</code> compact revision 30000, 33000, and 36000, for every 3-minute, while <code>v3.3.3</code> <em>or later</em> compacts revision 30000, 60000, and 90000, for every 30-minute.</p><h2 id=defragmentation>Defragmentation</h2><p>After compacting the keyspace, the backend database may exhibit internal fragmentation. Any internal fragmentation is space that is free to use by the backend but still consumes storage space. Compacting old revisions internally fragments <code>etcd</code> by leaving gaps in backend database. Fragmented space is available for use by <code>etcd</code> but unavailable to the host filesystem. In other words, deleting application data does not reclaim the space on disk.</p><p>The process of defragmentation releases this storage space back to the file system. Defragmentation is issued on a per-member basis so that cluster-wide latency spikes may be avoided.</p><p>To defragment an etcd member, use the <code>etcdctl defrag</code> command:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>$ etcdctl defrag
</span></span><span style=display:flex><span>Finished defragmenting etcd member<span style=color:#ce5c00;font-weight:700>[</span>127.0.0.1:2379<span style=color:#ce5c00;font-weight:700>]</span>
</span></span></code></pre></div><p><strong>Note that defragmentation to a live member blocks the system from reading and writing data while rebuilding its states</strong>.</p><p><strong>Note that defragmentation request does not get replicated over cluster. That is, the request is only applied to the local node. Specify all members in <code>--endpoints</code> flag or <code>--cluster</code> flag to automatically find all cluster members.</strong></p><p>Run defragment operations for all endpoints in the cluster associated with the default endpoint:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ etcdctl defrag --cluster
</span></span><span style=display:flex><span>Finished defragmenting etcd member<span style=color:#ce5c00;font-weight:700>[</span>http://127.0.0.1:2379<span style=color:#ce5c00;font-weight:700>]</span>
</span></span><span style=display:flex><span>Finished defragmenting etcd member<span style=color:#ce5c00;font-weight:700>[</span>http://127.0.0.1:22379<span style=color:#ce5c00;font-weight:700>]</span>
</span></span><span style=display:flex><span>Finished defragmenting etcd member<span style=color:#ce5c00;font-weight:700>[</span>http://127.0.0.1:32379<span style=color:#ce5c00;font-weight:700>]</span>
</span></span></code></pre></div><p>To defragment an etcd data directory directly, while etcd is not running, use the command:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>$ etcdctl defrag --data-dir &lt;path-to-etcd-data-dir&gt;
</span></span></code></pre></div><h2 id=space-quota>Space quota</h2><p>The space quota in <code>etcd</code> ensures the cluster operates in a reliable fashion. Without a space quota, <code>etcd</code> may suffer from poor performance if the keyspace grows excessively large, or it may simply run out of storage space, leading to unpredictable cluster behavior. If the keyspace&rsquo;s backend database for any member exceeds the space quota, <code>etcd</code> raises a cluster-wide alarm that puts the cluster into a maintenance mode which only accepts key reads and deletes. Only after freeing enough space in the keyspace and defragmenting the backend database, along with clearing the space quota alarm can the cluster resume normal operation.</p><p>By default, <code>etcd</code> sets a conservative space quota suitable for most applications, but it may be configured on the command line, in bytes:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span><span style=color:#8f5902;font-style:italic># set a very small 16 MiB quota</span>
</span></span><span style=display:flex><span>$ etcd --quota-backend-bytes<span style=color:#ce5c00;font-weight:700>=</span><span style=color:#204a87;font-weight:700>$((</span><span style=color:#0000cf;font-weight:700>16</span><span style=color:#ce5c00;font-weight:700>*</span><span style=color:#0000cf;font-weight:700>1024</span><span style=color:#ce5c00;font-weight:700>*</span><span style=color:#0000cf;font-weight:700>1024</span><span style=color:#204a87;font-weight:700>))</span>
</span></span></code></pre></div><p>The space quota can be triggered with a loop:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span><span style=color:#8f5902;font-style:italic># fill keyspace</span>
</span></span><span style=display:flex><span>$ <span style=color:#204a87;font-weight:700>while</span> <span style=color:#ce5c00;font-weight:700>[</span> <span style=color:#0000cf;font-weight:700>1</span> <span style=color:#ce5c00;font-weight:700>]</span><span style=color:#000;font-weight:700>;</span> <span style=color:#204a87;font-weight:700>do</span> dd <span style=color:#204a87;font-weight:700>if</span><span style=color:#ce5c00;font-weight:700>=</span>/dev/urandom <span style=color:#000>bs</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#0000cf;font-weight:700>1024</span> <span style=color:#000>count</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#0000cf;font-weight:700>1024</span>  <span style=color:#000;font-weight:700>|</span> <span style=color:#000>ETCDCTL_API</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#0000cf;font-weight:700>3</span> etcdctl put key  <span style=color:#ce5c00;font-weight:700>||</span> break<span style=color:#000;font-weight:700>;</span> <span style=color:#204a87;font-weight:700>done</span>
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span>Error:  rpc error: <span style=color:#000>code</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#0000cf;font-weight:700>8</span> <span style=color:#000>desc</span> <span style=color:#ce5c00;font-weight:700>=</span> etcdserver: mvcc: database space exceeded
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic># confirm quota space is exceeded</span>
</span></span><span style=display:flex><span>$ <span style=color:#000>ETCDCTL_API</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#0000cf;font-weight:700>3</span> etcdctl --write-out<span style=color:#ce5c00;font-weight:700>=</span>table endpoint status
</span></span><span style=display:flex><span>+----------------+------------------+-----------+---------+-----------+-----------+------------+
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>|</span>    ENDPOINT    <span style=color:#000;font-weight:700>|</span>        ID        <span style=color:#000;font-weight:700>|</span>  VERSION  <span style=color:#000;font-weight:700>|</span> DB SIZE <span style=color:#000;font-weight:700>|</span> IS LEADER <span style=color:#000;font-weight:700>|</span> RAFT TERM <span style=color:#000;font-weight:700>|</span> RAFT INDEX <span style=color:#000;font-weight:700>|</span>
</span></span><span style=display:flex><span>+----------------+------------------+-----------+---------+-----------+-----------+------------+
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>|</span> 127.0.0.1:2379 <span style=color:#000;font-weight:700>|</span> bf9071f4639c75cc <span style=color:#000;font-weight:700>|</span> 2.3.0+git <span style=color:#000;font-weight:700>|</span> <span style=color:#0000cf;font-weight:700>18</span> MB   <span style=color:#000;font-weight:700>|</span> <span style=color:#204a87>true</span>      <span style=color:#000;font-weight:700>|</span>         <span style=color:#0000cf;font-weight:700>2</span> <span style=color:#000;font-weight:700>|</span>       <span style=color:#0000cf;font-weight:700>3332</span> <span style=color:#000;font-weight:700>|</span>
</span></span><span style=display:flex><span>+----------------+------------------+-----------+---------+-----------+-----------+------------+
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic># confirm alarm is raised</span>
</span></span><span style=display:flex><span>$ <span style=color:#000>ETCDCTL_API</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#0000cf;font-weight:700>3</span> etcdctl alarm list
</span></span><span style=display:flex><span>memberID:13803658152347727308 alarm:NOSPACE
</span></span></code></pre></div><p>Removing excessive keyspace data and defragmenting the backend database will put the cluster back within the quota limits:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span><span style=color:#8f5902;font-style:italic># get current revision</span>
</span></span><span style=display:flex><span>$ <span style=color:#000>rev</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#204a87;font-weight:700>$(</span><span style=color:#000>ETCDCTL_API</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#0000cf;font-weight:700>3</span> etcdctl --endpoints<span style=color:#ce5c00;font-weight:700>=</span>:2379 endpoint status --write-out<span style=color:#ce5c00;font-weight:700>=</span><span style=color:#4e9a06>&#34;json&#34;</span> <span style=color:#000;font-weight:700>|</span> egrep -o <span style=color:#4e9a06>&#39;&#34;revision&#34;:[0-9]*&#39;</span> <span style=color:#000;font-weight:700>|</span> egrep -o <span style=color:#4e9a06>&#39;[0-9].*&#39;</span><span style=color:#204a87;font-weight:700>)</span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic># compact away all old revisions</span>
</span></span><span style=display:flex><span>$ <span style=color:#000>ETCDCTL_API</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#0000cf;font-weight:700>3</span> etcdctl compact <span style=color:#000>$rev</span>
</span></span><span style=display:flex><span>compacted revision <span style=color:#0000cf;font-weight:700>1516</span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic># defragment away excessive space</span>
</span></span><span style=display:flex><span>$ <span style=color:#000>ETCDCTL_API</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#0000cf;font-weight:700>3</span> etcdctl defrag
</span></span><span style=display:flex><span>Finished defragmenting etcd member<span style=color:#ce5c00;font-weight:700>[</span>127.0.0.1:2379<span style=color:#ce5c00;font-weight:700>]</span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic># disarm alarm</span>
</span></span><span style=display:flex><span>$ <span style=color:#000>ETCDCTL_API</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#0000cf;font-weight:700>3</span> etcdctl alarm disarm
</span></span><span style=display:flex><span>memberID:13803658152347727308 alarm:NOSPACE
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic># test puts are allowed again</span>
</span></span><span style=display:flex><span>$ <span style=color:#000>ETCDCTL_API</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#0000cf;font-weight:700>3</span> etcdctl put newkey <span style=color:#0000cf;font-weight:700>123</span>
</span></span><span style=display:flex><span>OK
</span></span></code></pre></div><p>The metric <code>etcd_mvcc_db_total_size_in_use_in_bytes</code> indicates the actual database usage after a history compaction, while <code>etcd_debugging_mvcc_db_total_size_in_bytes</code> shows the database size including free space waiting for defragmentation. The latter increases only when the former is close to it, meaning when both of these metrics are close to the quota, a history compaction is required to avoid triggering the space quota.</p><p><code>etcd_debugging_mvcc_db_total_size_in_bytes</code> is renamed to <code>etcd_mvcc_db_total_size_in_bytes</code> from v3.4.</p><p><strong>NOTE:</strong> it is possible to get an <code>ErrGRPCNoSpace</code> error for a Put/Txn/LeaseGrant request, and still have the write request succeed in the backend, because etcd checks space quota at the API layer and the internal Apply layer, and the Apply layer will only raise the <code>NOSPACE</code> alarm without blocking the transaction from proceeding.</p><h2 id=snapshot-backup>Snapshot backup</h2><p>Snapshotting the <code>etcd</code> cluster on a regular basis serves as a durable backup for an etcd keyspace. By taking periodic snapshots of an etcd member&rsquo;s backend database, an <code>etcd</code> cluster can be recovered to a point in time with a known good state.</p><p>A snapshot is taken with <code>etcdctl</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>$ etcdctl snapshot save backup.db
</span></span><span style=display:flex><span>$ etcdutl --write-out<span style=color:#ce5c00;font-weight:700>=</span>table snapshot status backup.db
</span></span><span style=display:flex><span>+----------+----------+------------+------------+
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>|</span>   HASH   <span style=color:#000;font-weight:700>|</span> REVISION <span style=color:#000;font-weight:700>|</span> TOTAL KEYS <span style=color:#000;font-weight:700>|</span> TOTAL SIZE <span style=color:#000;font-weight:700>|</span>
</span></span><span style=display:flex><span>+----------+----------+------------+------------+
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>|</span> fe01cf57 <span style=color:#000;font-weight:700>|</span>       <span style=color:#0000cf;font-weight:700>10</span> <span style=color:#000;font-weight:700>|</span>          <span style=color:#0000cf;font-weight:700>7</span> <span style=color:#000;font-weight:700>|</span> 2.1 MB     <span style=color:#000;font-weight:700>|</span>
</span></span><span style=display:flex><span>+----------+----------+------------+------------+
</span></span></code></pre></div><div class=d-print-none><h2 class=feedback--title>Feedback</h2><p class=feedback--question>Was this page helpful?</p><button class="btn btn-primary mb-4 feedback--answer feedback--answer-yes">Yes</button>
<button class="btn btn-primary mb-4 feedback--answer feedback--answer-no">No</button><p class="feedback--response feedback--response-yes">Glad to hear it! Please <a href=https://github.com/etcd-io/website/issues/new>tell us how we can improve</a>.</p><p class="feedback--response feedback--response-no">Sorry to hear that. Please <a href=https://github.com/etcd-io/website/issues/new>tell us how we can improve</a>.</p></div><br><div class=td-page-meta__lastmod>Last modified August 17, 2024: <a href=https://github.com/etcd-io/website/commit/264cc3ea5f2b3be1d36a1e5085cba73f4761c318>fix typo (264cc3e)</a></div></div></main></div></div></div></body></html>