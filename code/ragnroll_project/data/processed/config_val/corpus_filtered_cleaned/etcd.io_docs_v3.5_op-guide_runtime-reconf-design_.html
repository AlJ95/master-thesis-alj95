<!doctype html><html itemscope itemtype=http://schema.org/WebPage lang=en class=no-js><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Design of runtime reconfiguration | etcd</title>
<meta name=description content="The design of etcd’s runtime reconfiguration commands"><meta property="og:url" content="https://etcd.io/docs/v3.5/op-guide/runtime-reconf-design/"><meta property="og:site_name" content="etcd"><meta property="og:title" content="Design of runtime reconfiguration"><meta property="og:description" content="The design of etcd’s runtime reconfiguration commands"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="docs"><meta property="article:modified_time" content="2021-08-19T16:37:01-04:00"><meta itemprop=name content="Design of runtime reconfiguration"><meta itemprop=description content="The design of etcd’s runtime reconfiguration commands"><meta itemprop=dateModified content="2021-08-19T16:37:01-04:00"><meta itemprop=wordCount content="784"><meta name=twitter:card content="summary"><meta name=twitter:title content="Design of runtime reconfiguration"><meta name=twitter:description content="The design of etcd’s runtime reconfiguration commands"></head><body class=td-page><div class="container-fluid td-outer"><div class=td-main><div class="row flex-xl-nowrap"><main class="col-12 col-md-9 col-xl-8 ps-md-5" role=main><div class=td-content><h1>Design of runtime reconfiguration</h1><div class=lead>The design of etcd’s runtime reconfiguration commands</div><p>Runtime reconfiguration is one of the hardest and most error prone features in a distributed system, especially in a consensus based system like etcd.</p><p>Read on to learn about the design of etcd&rsquo;s runtime reconfiguration commands and how we tackled these problems.</p><h2 id=two-phase-config-changes-keep-the-cluster-safe>Two phase config changes keep the cluster safe</h2><p>In etcd, every runtime reconfiguration has to go through <a href=../runtime-configuration/#add-a-new-member>two phases</a> for safety reasons. For example, to add a member, first inform the cluster of the new configuration and then start the new member.</p><p>Phase 1 - Inform cluster of new configuration</p><p>To add a member into an etcd cluster, make an API call to request a new member to be added to the cluster. This is the only way to add a new member into an existing cluster. The API call returns when the cluster agrees on the configuration change.</p><p>Phase 2 - Start new member</p><p>To join the new etcd member into the existing cluster, specify the correct <code>initial-cluster</code> and set <code>initial-cluster-state</code> to <code>existing</code>. When the member starts, it will contact the existing cluster first and verify the current cluster configuration matches the expected one specified in <code>initial-cluster</code>. When the new member successfully starts, the cluster has reached the expected configuration.</p><p>By splitting the process into two discrete phases users are forced to be explicit regarding cluster membership changes. This actually gives users more flexibility and makes things easier to reason about. For example, if there is an attempt to add a new member with the same ID as an existing member in an etcd cluster, the action will fail immediately during phase one without impacting the running cluster. Similar protection is provided to prevent adding new members by mistake. If a new etcd member attempts to join the cluster before the cluster has accepted the configuration change, it will not be accepted by the cluster.</p><p>Without the explicit workflow around cluster membership etcd would be vulnerable to unexpected cluster membership changes. For example, if etcd is running under an init system such as systemd, etcd would be restarted after being removed via the membership API, and attempt to rejoin the cluster on startup. This cycle would continue every time a member is removed via the API and systemd is set to restart etcd after failing, which is unexpected.</p><p>We expect runtime reconfiguration to be an infrequent operation. We decided to keep it explicit and user-driven to ensure configuration safety and keep the cluster always running smoothly under explicit control.</p><h2 id=permanent-loss-of-quorum-requires-new-cluster>Permanent loss of quorum requires new cluster</h2><p>If a cluster permanently loses a majority of its members, a new cluster will need to be started from an old data directory to recover the previous state.</p><p>It is entirely possible to force removing the failed members from the existing cluster to recover. However, we decided not to support this method since it bypasses the normal consensus committing phase, which is unsafe. If the member to remove is not actually dead or force removed through different members in the same cluster, etcd will end up with a diverged cluster with same clusterID. This is very dangerous and hard to debug/fix afterwards.</p><p>With a correct deployment, the possibility of permanent majority loss is very low. But it is a severe enough problem that is worth special care. We strongly suggest reading the <a href=../recovery/>disaster recovery documentation</a> and preparing for permanent majority loss before putting etcd into production.</p><h2 id=do-not-use-public-discovery-service-for-runtime-reconfiguration>Do not use public discovery service for runtime reconfiguration</h2><p>The public discovery service should only be used for bootstrapping a cluster. To join member into an existing cluster, use the runtime reconfiguration API.</p><p>The discovery service is designed for bootstrapping an etcd cluster in a cloud environment, when the IP addresses of all the members are not known beforehand. After successfully bootstrapping a cluster, the IP addresses of all the members are known. Technically, the discovery service should no longer be needed.</p><p>It seems that using public discovery service is a convenient way to do runtime reconfiguration, after all discovery service already has all the cluster configuration information. However relying on public discovery service brings troubles:</p><ol><li><p>it introduces external dependencies for the entire life-cycle of the cluster, not just bootstrap time. If there is a network issue between the cluster and public discovery service, the cluster will suffer from it.</p></li><li><p>public discovery service must reflect correct runtime configuration of the cluster during its life-cycle. It has to provide security mechanisms to avoid bad actions, and it is hard.</p></li><li><p>public discovery service has to keep tens of thousands of cluster configurations. Our public discovery service backend is not ready for that workload.</p></li></ol><p>To have a discovery service that supports runtime reconfiguration, the best choice is to build a private one.</p><div class=d-print-none><h2 class=feedback--title>Feedback</h2><p class=feedback--question>Was this page helpful?</p><button class="btn btn-primary mb-4 feedback--answer feedback--answer-yes">Yes</button>
<button class="btn btn-primary mb-4 feedback--answer feedback--answer-no">No</button><p class="feedback--response feedback--response-yes">Glad to hear it! Please <a href=https://github.com/etcd-io/website/issues/new>tell us how we can improve</a>.</p><p class="feedback--response feedback--response-no">Sorry to hear that. Please <a href=https://github.com/etcd-io/website/issues/new>tell us how we can improve</a>.</p></div><br><div class=td-page-meta__lastmod>Last modified August 19, 2021: <a href=https://github.com/etcd-io/website/commit/cb192bf87e7641b17d5b1838098a8c10e47927ad>fix v3.5 links (#457) (cb192bf)</a></div></div></main></div></div></div></body></html>