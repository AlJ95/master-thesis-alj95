<!doctype html><html itemscope itemtype=http://schema.org/WebPage lang=en class=no-js><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>FAQ | etcd</title>
<meta name=description content="Frequently asked questions"><meta property="og:url" content="https://etcd.io/docs/v3.5/faq/"><meta property="og:site_name" content="etcd"><meta property="og:title" content="FAQ"><meta property="og:description" content="Frequently asked questions"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="docs"><meta property="article:modified_time" content="2024-12-05T01:25:33+00:00"><meta itemprop=name content="FAQ"><meta itemprop=description content="Frequently asked questions"><meta itemprop=dateModified content="2024-12-05T01:25:33+00:00"><meta itemprop=wordCount content="2575"><meta name=twitter:card content="summary"><meta name=twitter:title content="FAQ"><meta name=twitter:description content="Frequently asked questions"></head><body class=td-page><div class="container-fluid td-outer"><div class=td-main><div class="row flex-xl-nowrap"><main class="col-12 col-md-9 col-xl-8 ps-md-5" role=main><div class=td-content><h1>FAQ</h1><div class=lead>Frequently asked questions</div><h2 id=etcd-general>etcd, general</h2><h3 id=what-is-etcd>What is etcd?</h3><p>etcd is a consistent distributed key-value store. Mainly used as a separate coordination service, in distributed systems. And designed to hold small amounts of data that can fit entirely in memory.</p><h3 id=how-do-you-pronounce-etcd>How do you pronounce etcd?</h3><p>etcd is pronounced <strong>/ˈɛtsiːdiː/</strong>, and means &ldquo;distributed <code>etc</code> directory.&rdquo;</p><h3 id=do-clients-have-to-send-requests-to-the-etcd-leader>Do clients have to send requests to the etcd leader?</h3><p><a href=https://raft.github.io/raft.pdf target=_blank rel=noopener>Raft</a> is leader-based; the leader handles all client requests which need cluster consensus. However, the client does not need to know which node is the leader. Any request that requires consensus sent to a follower is automatically forwarded to the leader. Requests that do not require consensus (e.g., serialized reads) can be processed by any cluster member.</p><h2 id=configuration>Configuration</h2><h3 id=what-is-the-difference-between-listen-clientpeer-urls-advertise-client-urls-or-initial-advertise-peer-urls>What is the difference between listen-&lt;client,peer>-urls, advertise-client-urls or initial-advertise-peer-urls?</h3><p><code>listen-client-urls</code> and <code>listen-peer-urls</code> specify the local addresses etcd server binds to for accepting incoming connections. To listen on a port for all interfaces, specify <code>0.0.0.0</code> as the listen IP address.</p><p><code>advertise-client-urls</code> and <code>initial-advertise-peer-urls</code> specify the addresses etcd clients or other etcd members should use to contact the etcd server. The advertise addresses must be reachable from the remote machines. Do not advertise addresses like <code>localhost</code> or <code>0.0.0.0</code> for a production setup since these addresses are unreachable from remote machines.</p><h3 id=why-doesnt-changing---listen-peer-urls-or---initial-advertise-peer-urls-update-the-advertised-peer-urls-in-etcdctl-member-list>Why doesn&rsquo;t changing <code>--listen-peer-urls</code> or <code>--initial-advertise-peer-urls</code> update the advertised peer URLs in <code>etcdctl member list</code>?</h3><p>A member&rsquo;s advertised peer URLs come from <code>--initial-advertise-peer-urls</code> on initial cluster boot. Changing the listen peer URLs or the initial advertise peers after booting the member won&rsquo;t affect the exported advertise peer URLs since changes must go through quorum to avoid membership configuration split brain. Use <code>etcdctl member update</code> to update a member&rsquo;s peer URLs.</p><h2 id=deployment>Deployment</h2><h3 id=system-requirements>System requirements</h3><p>Since etcd writes data to disk, its performance strongly depends on disk performance. For this reason, SSD is highly recommended. To assess whether a disk is fast enough for etcd, one possibility is using a disk benchmarking tool such as <a href=https://github.com/axboe/fio target=_blank rel=noopener>fio</a>. For an example on how to do that, read <a href=https://web.archive.org/web/20240726111518/https://prog.world/is-storage-speed-suitable-for-etcd-ask-fio/ target=_blank rel=noopener>here</a>. To prevent performance degradation or unintentionally overloading the key-value store, etcd enforces a configurable storage size quota set to 2GB by default. To avoid swapping or running out of memory, the machine should have at least as much RAM to cover the quota. 8GB is a suggested maximum size for normal environments and etcd warns at startup if the configured value exceeds it. At CoreOS, an etcd cluster is usually deployed on dedicated CoreOS Container Linux machines with dual-core processors, 2GB of RAM, and 80GB of SSD <em>at the very least</em>. <strong>Note that performance is intrinsically workload dependent; please test before production deployment</strong>. See <a href=../op-guide/hardware/>hardware</a> for more recommendations.</p><p>Most stable production environment is Linux operating system with amd64 architecture; see <a href=../op-guide/supported-platform/>supported platform</a> for more.</p><h3 id=why-an-odd-number-of-cluster-members>Why an odd number of cluster members?</h3><p>An etcd cluster needs a majority of nodes, a quorum, to agree on updates to the cluster state. For a cluster with n members, quorum is (n/2)+1. For any odd-sized cluster, adding one node will always increase the number of nodes necessary for quorum. Although adding a node to an odd-sized cluster appears better since there are more machines, the fault tolerance is worse since exactly the same number of nodes may fail without losing quorum but there are more nodes that can fail. If the cluster is in a state where it can&rsquo;t tolerate any more failures, adding a node before removing nodes is dangerous because if the new node fails to register with the cluster (e.g., the address is misconfigured), quorum will be permanently lost.</p><h3 id=what-is-maximum-cluster-size>What is maximum cluster size?</h3><p>Theoretically, there is no hard limit. However, an etcd cluster probably should have no more than seven nodes. <a href=http://static.googleusercontent.com/media/research.google.com/en//archive/chubby-osdi06.pdf target=_blank rel=noopener>Google Chubby lock service</a>, similar to etcd and widely deployed within Google for many years, suggests running five nodes. A 5-member etcd cluster can tolerate two member failures, which is enough in most cases. Although larger clusters provide better fault tolerance, the write performance suffers because data must be replicated across more machines.</p><h3 id=what-is-failure-tolerance>What is failure tolerance?</h3><p>An etcd cluster operates so long as a member quorum can be established. If quorum is lost through transient network failures (e.g., partitions), etcd automatically and safely resumes once the network recovers and restores quorum; Raft enforces cluster consistency. For power loss, etcd persists the Raft log to disk; etcd replays the log to the point of failure and resumes cluster participation. For permanent hardware failure, the node may be removed from the cluster through <a href=../op-guide/runtime-configuration/>runtime reconfiguration</a>.</p><p>It is recommended to have an odd number of members in a cluster. An odd-size cluster tolerates the same number of failures as an even-size cluster but with fewer nodes. The difference can be seen by comparing even and odd sized clusters:</p><table><thead><tr><th style=text-align:center>Cluster Size</th><th style=text-align:center>Majority</th><th style=text-align:center>Failure Tolerance</th></tr></thead><tbody><tr><td style=text-align:center>1</td><td style=text-align:center>1</td><td style=text-align:center>0</td></tr><tr><td style=text-align:center>2</td><td style=text-align:center>2</td><td style=text-align:center>0</td></tr><tr><td style=text-align:center>3</td><td style=text-align:center>2</td><td style=text-align:center>1</td></tr><tr><td style=text-align:center>4</td><td style=text-align:center>3</td><td style=text-align:center>1</td></tr><tr><td style=text-align:center>5</td><td style=text-align:center>3</td><td style=text-align:center>2</td></tr><tr><td style=text-align:center>6</td><td style=text-align:center>4</td><td style=text-align:center>2</td></tr><tr><td style=text-align:center>7</td><td style=text-align:center>4</td><td style=text-align:center>3</td></tr><tr><td style=text-align:center>8</td><td style=text-align:center>5</td><td style=text-align:center>3</td></tr><tr><td style=text-align:center>9</td><td style=text-align:center>5</td><td style=text-align:center>4</td></tr></tbody></table><p>Adding a member to bring the size of cluster up to an even number doesn&rsquo;t buy additional fault tolerance. Likewise, during a network partition, an odd number of members guarantees that there will always be a majority partition that can continue to operate and be the source of truth when the partition ends.</p><h3 id=does-etcd-work-in-cross-region-or-cross-data-center-deployments>Does etcd work in cross-region or cross data center deployments?</h3><p>Deploying etcd across regions improves etcd&rsquo;s fault tolerance since members are in separate failure domains. The cost is higher consensus request latency from crossing data center boundaries. Since etcd relies on a member quorum for consensus, the latency from crossing data centers will be somewhat pronounced because at least a majority of cluster members must respond to consensus requests. Additionally, cluster data must be replicated across all peers, so there will be bandwidth cost as well.</p><p>With longer latencies, the default etcd configuration may cause frequent elections or heartbeat timeouts. See <a href=../tuning/>tuning</a> for adjusting timeouts for high latency deployments.</p><h2 id=operation>Operation</h2><h3 id=how-to-backup-a-etcd-cluster>How to backup a etcd cluster?</h3><p>etcdctl provides a <code>snapshot</code> command to create backups. See <a href=../op-guide/recovery/#snapshotting-the-keyspace>backup</a> for more details.</p><h3 id=should-i-add-a-member-before-removing-an-unhealthy-member>Should I add a member before removing an unhealthy member?</h3><p>When replacing an etcd node, it&rsquo;s important to remove the member first and then add its replacement.</p><p>etcd employs distributed consensus based on a quorum model; (n/2)+1 members, a majority, must agree on a proposal before it can be committed to the cluster. These proposals include key-value updates and membership changes. This model totally avoids any possibility of split brain inconsistency. The downside is permanent quorum loss is catastrophic.</p><p>How this applies to membership: If a 3-member cluster has 1 downed member, it can still make forward progress because the quorum is 2 and 2 members are still live. However, adding a new member to a 3-member cluster will increase the quorum to 3 because 3 votes are required for a majority of 4 members. Since the quorum increased, this extra member buys nothing in terms of fault tolerance; the cluster is still one node failure away from being unrecoverable.</p><p>Additionally, that new member is risky because it may turn out to be misconfigured or incapable of joining the cluster. In that case, there&rsquo;s no way to recover quorum because the cluster has two members down and two members up, but needs three votes to change membership to undo the botched membership addition. etcd will by default reject member add attempts that could take down the cluster in this manner.</p><p>On the other hand, if the downed member is removed from cluster membership first, the number of members becomes 2 and the quorum remains at 2. Following that removal by adding a new member will also keep the quorum steady at 2. So, even if the new node can&rsquo;t be brought up, it&rsquo;s still possible to remove the new member through quorum on the remaining live members.</p><h3 id=why-wont-etcd-accept-my-membership-changes>Why won&rsquo;t etcd accept my membership changes?</h3><p>etcd sets <code>strict-reconfig-check</code> in order to reject reconfiguration requests that would cause quorum loss. Abandoning quorum is really risky (especially when the cluster is already unhealthy). Although it may be tempting to disable quorum checking if there&rsquo;s quorum loss to add a new member, this could lead to full fledged cluster inconsistency. For many applications, this will make the problem even worse (&ldquo;disk geometry corruption&rdquo; being a candidate for most terrifying).</p><h3 id=why-does-etcd-lose-its-leader-from-disk-latency-spikes>Why does etcd lose its leader from disk latency spikes?</h3><p>This is intentional; disk latency is part of leader liveness. Suppose the cluster leader takes a minute to fsync a raft log update to disk, but the etcd cluster has a one second election timeout. Even though the leader can process network messages within the election interval (e.g., send heartbeats), it&rsquo;s effectively unavailable because it can&rsquo;t commit any new proposals; it&rsquo;s waiting on the slow disk. If the cluster frequently loses its leader due to disk latencies, try <a href=../tuning/>tuning</a> the disk settings or etcd time parameters.</p><h3 id=what-does-the-etcd-warning-request-ignored-cluster-id-mismatch-mean>What does the etcd warning &ldquo;request ignored (cluster ID mismatch)&rdquo; mean?</h3><p>Every new etcd cluster generates a new cluster ID based on the initial cluster configuration and a user-provided unique <code>initial-cluster-token</code> value. By having unique cluster ID&rsquo;s, etcd is protected from cross-cluster interaction which could corrupt the cluster.</p><p>Usually this warning happens after tearing down an old cluster, then reusing some of the peer addresses for the new cluster. If any etcd process from the old cluster is still running it will try to contact the new cluster. The new cluster will recognize a cluster ID mismatch, then ignore the request and emit this warning. This warning is often cleared by ensuring peer addresses among distinct clusters are disjoint.</p><h3 id=what-does-mvcc-database-space-exceeded-mean-and-how-do-i-fix-it>What does &ldquo;mvcc: database space exceeded&rdquo; mean and how do I fix it?</h3><p>The <a href=../learning/api/#revisions>multi-version concurrency control</a> data model in etcd keeps an exact history of the keyspace. Without periodically compacting this history (e.g., by setting <code>--auto-compaction</code>), etcd will eventually exhaust its storage space. If etcd runs low on storage space, it raises a space quota alarm to protect the cluster from further writes. So long as the alarm is raised, etcd responds to write requests with the error <code>mvcc: database space exceeded</code>.</p><p>To recover from the low space quota alarm:</p><ol></ul></div><div class="td-footer__right col-6 col-sm-4 order-sm-3"><ul class=td-footer__links-list></ul></div><div class="td-footer__center col-12 col-sm-4 py-2 order-sm-2"><span class=td-footer__copyright>&copy;
2013&ndash;2025
<span class=td-footer__authors><p>etcd Authors</p><div class="row text-center text-white small"><div class="col-12 text-center py-2 order-sm-2"><a href=https://www.linuxfoundation.org/terms target=_blank rel=noopener>Terms</a> |
<a href=https://www.linuxfoundation.org/privacy target=_blank rel=noopener>Privacy</a> |
<a href=https://www.linuxfoundation.org/trademark-usage target=_blank rel=noopener>Trademarks</a> |
<a href=https://github.com/etcd-io/website/blob/main/LICENSE target=_blank rel=noopener>License</a></div></div></span></span><span class=td-footer__all_rights_reserved>All Rights Reserved</span></div></div></div></footer></div></body></html>