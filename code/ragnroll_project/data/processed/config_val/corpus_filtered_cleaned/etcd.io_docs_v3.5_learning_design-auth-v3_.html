<!doctype html><html itemscope itemtype=http://schema.org/WebPage lang=en class=no-js><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>etcd v3 authentication design | etcd</title>
<meta name=description content="etcd v3 authentication"><meta property="og:url" content="https://etcd.io/docs/v3.5/learning/design-auth-v3/"><meta property="og:site_name" content="etcd"><meta property="og:title" content="etcd v3 authentication design"><meta property="og:description" content="etcd v3 authentication"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="docs"><meta property="article:modified_time" content="2024-08-19T23:55:40+05:30"><meta itemprop=name content="etcd v3 authentication design"><meta itemprop=description content="etcd v3 authentication"><meta itemprop=dateModified content="2024-08-19T23:55:40+05:30"><meta itemprop=wordCount content="1442"><meta name=twitter:card content="summary"><meta name=twitter:title content="etcd v3 authentication design"><meta name=twitter:description content="etcd v3 authentication"></head><body class=td-page><div class="container-fluid td-outer"><div class=td-main><div class="row flex-xl-nowrap"><main class="col-12 col-md-9 col-xl-8 ps-md-5" role=main><div class=td-content><h1>etcd v3 authentication design</h1><div class=lead>etcd v3 authentication</div><h2 id=why-not-reuse-the-v2-auth-system>Why not reuse the v2 auth system?</h2><p>The v3 protocol uses gRPC as its transport instead of a RESTful interface like v2. This new protocol provides an opportunity to iterate on and improve the v2 design. For example, v3 auth has connection based authentication, rather than v2&rsquo;s slower per-request authentication. Additionally, v2 auth&rsquo;s semantics tend to be unwieldy in practice with respect to reasoning about consistency, which will be described in the next sections. For v3, there is a well-defined description and implementation of the authentication mechanism which fixes the deficiencies in the v2 auth system.</p><h3 id=functionality-requirements>Functionality requirements</h3><ul><li>Per connection authentication, not per request<ul><li>User ID + password based authentication implemented for the gRPC API</li><li>Authentication must be refreshed after auth policy changes</li></ul></li><li>Its functionality should be as simple and useful as v2<ul><li>v3 provides a flat key space, unlike the directory structure of v2. Permission checking will be provided as interval matching.</li></ul></li><li>It should have stronger consistency guarantees than v2 auth</li></ul><h3 id=main-required-changes>Main required changes</h3><ul><li>A client must create a dedicated connection only for authentication before sending authenticated requests</li><li>Add permission information (user ID and authorized revision) to the Raft commands (<code>etcdserverpb.InternalRaftRequest</code>)</li><li>Every request is permission checked in the state machine layer, rather than API layer</li></ul><h3 id=permission-metadata-consistency>Permission metadata consistency</h3><p>The metadata for auth should also be stored and managed in the storage controlled by etcd&rsquo;s Raft protocol like other data stored in etcd. It is required for not sacrificing availability and consistency of the entire etcd cluster. If reading or writing the metadata (e.g. permission information) needs an agreement of every node (more than quorum), single node failure can stop the entire cluster. Requiring all nodes to agree at once means that checking ordinary read/write requests cannot be completed if any cluster member is down, even if the cluster has an available quorum. This unanimous scheme ultimately degrades cluster availability; quorum based consensus from raft should suffice since agreement follows from consistent ordering.</p><p>The authentication mechanism in the etcd v2 protocol has a tricky part because the metadata consistency should work as in the above, but does not: each permission check is processed by the etcd member that receives the client request (server/etcdserver/api/v2http/client.go), including follower members. Therefore, it&rsquo;s possible the check may be based on stale metadata.</p><p>This staleness means that auth configuration cannot be reflected as soon as operators execute etcdctl. Therefore there is no way to know how long the stale metadata is active. Practically, the configuration change is reflected immediately after the command execution. However, in some cases of heavy load, the inconsistent state can be prolonged and it might result in counter-intuitive situations for users and developers. It requires a workaround like this: <a href=https://github.com/etcd-io/etcd/pull/4317#issuecomment-179037582 target=_blank rel=noopener>https://github.com/etcd-io/etcd/pull/4317#issuecomment-179037582</a></p><h3 id=inconsistent-permissions-are-unsafe-for-linearized-requests>Inconsistent permissions are unsafe for linearized requests</h3><p>Inconsistent authentication state is most serious for writes. Even if an operator disables write on a user, if the write is only ordered with respect to the key value store but not the authentication system, it&rsquo;s possible the write will complete successfully. Without ordering on both the auth store and the key-value store, the system will be susceptible to stale permission attacks.</p><p>Therefore, the permission checking logic should be added to the state machine of etcd. Each state machine should check the requests based on its permission information in the apply phase (so the auth information must not be stale).</p><h2 id=design-and-implementation>Design and implementation</h2><h3 id=authentication>Authentication</h3><p>At first, a client must create a gRPC connection only to authenticate its user ID and password. An etcd server will respond with an authentication reply. The response will be an authentication token on success or an error on failure. The client can use its authentication token to present its credentials to etcd when making API requests.</p><p>The client connection used to request the authentication token is typically thrown away; it cannot carry the new token&rsquo;s credentials. This is because gRPC doesn&rsquo;t provide a way for adding per RPC credential after creation of the connection (calling <code>grpc.Dial()</code>). Therefore, a client cannot assign a token to its connection that is obtained through the connection. The client needs a new connection for using the token.</p><h4 id=notes-on-the-implementation-of-authenticate-rpc>Notes on the implementation of <code>Authenticate()</code> RPC</h4><p><code>Authenticate()</code> RPC generates an authentication token based on a given user name and password. etcd saves and checks a configured password and a given password using Go&rsquo;s <code>bcrypt</code> package. By design, <code>bcrypt</code>&rsquo;s password checking mechanism is computationally expensive, taking nearly 100ms on an ordinary x64 server. Therefore, performing this check in the state machine apply phase would cause performance trouble: the entire etcd cluster can only serve almost 10 <code>Authenticate()</code> requests per second.</p><p>For good performance, the v3 auth mechanism checks passwords in etcd&rsquo;s API layer, where it can be parallelized outside of raft. However, this can lead to potential time-of-check/time-of-use (TOCTOU) permission lapses:</p><ol><li>client A sends a request <code>Authenticate()</code></li><li>the API layer processes the password checking part of <code>Authenticate()</code></li><li>another client B sends a request of <code>ChangePassword()</code> and the server completes it</li><li>the state machine layer processes the part of getting a revision number for the <code>Authenticate()</code> from A</li><li>the server returns a success to A</li><li>now A is authenticated on an obsolete password</li></ol><p>For avoiding such a situation, the API layer performs <em>version number validation</em> based on the revision number of the auth store. During password checking, the API layer saves the revision number of auth store. After successful password checking, the API layer compares the saved revision number and the latest revision number. If the numbers differ, it means someone else updated the auth metadata. So it retries the checking. With this mechanism, the successful password checking based on the obsolete password can be avoided.</p><h3 id=resolving-a-token-in-the-api-layer>Resolving a token in the API layer</h3><p>After authenticating with <code>Authenticate()</code>, a client can create a gRPC connection as it would without auth. In addition to the existing initialization process, the client must associate the token with the newly created connection. <code>grpc.WithPerRPCCredentials()</code> provides the functionality for this purpose.</p><p>Every authenticated request from the client has a token. The token can be obtained with <code>grpc.metadata.FromIncomingContext()</code> in the server side. The server can obtain who is issuing the request and when the user was authorized. The information will be filled by the API layer in the header (<code>etcdserverpb.RequestHeader.Username</code> and <code>etcdserverpb.RequestHeader.AuthRevision</code>) of a raft log entry (<code>etcdserverpb.InternalRaftRequest</code>).</p><h3 id=checking-permission-in-the-state-machine>Checking permission in the state machine</h3><p>The auth info in <code>etcdserverpb.RequestHeader</code> is checked in the apply phase of the state machine. This step checks the user is granted permission to requested keys on the latest revision of auth store.</p><h3 id=two-types-of-tokens-simple-and-jwt>Two types of tokens: simple and JWT</h3><p>There are two kinds of token types: simple and JWT. The simple token isn&rsquo;t designed for production use cases. Its tokens aren&rsquo;t cryptographically signed and servers must statefully track token-user correspondence; it is meant for development testing. JWT tokens should be used for production deployments since it is cryptographically signed and verified. From the implementation perspective, JWT is stateless. Its token can include metadata including username and revision, so servers don&rsquo;t need to remember correspondence between tokens and the metadata.</p><p><strong>Note :</strong> There is a known issue <a href=https://github.com/etcd-io/etcd/issues/18437 target=_blank rel=noopener>#18437</a> with simple tokens. Within etcd servers, tokens are resolved at the API layer and simple tokens are stateful. The process is not protected by a linearizable check, meaning an etcd member may not have completed processing a previous authentication request before receiving the next one. In such cases, the member might return an &ldquo;invalid auth token&rdquo; error to the client. This issue is usually rare on a node with good network conditions but can occur if there is significant latency. As a workaround, applications can implement a retry mechanism to handle this error.</p><h2 id=notes-on-the-difference-between-kvs-models-and-file-system-models>Notes on the difference between KVS models and file system models</h2><p>etcd v3 is a KVS, not a file system. So the permissions can be granted to the users in form of an exact key name or a key range like <code>["start key", "end key")</code>. It means that granting a permission of a nonexistent key is possible. Users should care about unintended permission granting. In a case of file system like system (e.g. Chubby or ZooKeeper), an inode like data structure can include the permission information. So granting permission to a nonexist key won&rsquo;t be possible (except the case of sticky bits).</p><p>The etcd v3 model requires multiple lookup of the metadata unlike the file system like systems. The worst case lookup cost will be sum the user&rsquo;s total granted keys and intervals. The cost cannot be avoided because v3&rsquo;s flat key space is completely different from Unix&rsquo;s file system model (every inode includes permission metadata). Practically the cost won’t be a serious problem because the metadata is small enough to benefit from caching.</p><div class=d-print-none><h2 class=feedback--title>Feedback</h2><p class=feedback--question>Was this page helpful?</p><button class="btn btn-primary mb-4 feedback--answer feedback--answer-yes">Yes</button>
<button class="btn btn-primary mb-4 feedback--answer feedback--answer-no">No</button><p class="feedback--response feedback--response-yes">Glad to hear it! Please <a href=https://github.com/etcd-io/website/issues/new>tell us how we can improve</a>.</p><p class="feedback--response feedback--response-no">Sorry to hear that. Please <a href=https://github.com/etcd-io/website/issues/new>tell us how we can improve</a>.</p></div><br><div class=td-page-meta__lastmod>Last modified August 19, 2024: <a href=https://github.com/etcd-io/website/commit/65d913f443df0253c17d816b8dd31fbad89c7c47>update doc auth design with simple token known issue (65d913f)</a></div></div></main></div></div></div></body></html>