<!doctype html>
<html lang="en">
 <head>
  <title>PostgreSQL: Documentation: 13: 61.4. Index Locking Considerations</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta http-equiv="Content-Type" content="text/xhtml; charset=utf-8" />
   
  <meta name="theme-color" content="#336791"/>
  <meta name="copyright" content="The PostgreSQL Global Development Group" />
  <meta property="og:url" content="https://www.postgresql.org/docs/13/index-locking.html" />
  <meta property="og:type" content="article" />
  <meta property="article:published_time" content="2025-02-20T14:13:26" />
  <meta property="og:image" content="https://www.postgresql.org/media/img/about/press/elephant.png" />
  <meta property="og:title" content="61.4. Index Locking Considerations" />
  <meta property="og:description" content="61.4.&amp;nbsp;Index Locking Considerations Index access methods must handle concurrent updates of the index by multiple processes. The core PostgreSQL system …" />
  <meta property="og:site_name" content="PostgreSQL Documentation" />


  

  
  
  
  
  

  

  
  </head>
  <body>
    <div class="container-fluid">
      <div class="row justify-content-md-center">
        <div class="col">
          
          
        </div>
      </div>
      <div class="row justify-content-center pg-shout-box">
        <div class="col text-white text-center">February 20, 2025: <a href="/about/news/postgresql-174-168-1512-1417-and-1320-released-3018/">
  PostgreSQL 17.4, 16.8, 15.12, 14.17, and 13.20 Released!
</a>

</div>
      </div>
    </div>
    <div class="container-fluid margin">
      <div class="row">
        <div id="pgContentWrap" class="col-11">
          <div class="row">
            <div class="col-md-6 mb-2">
              <div class="row">
                <div class="col">
                  <div>
                    <a href="/docs/" title="Documentation">Documentation</a> &rarr; <a href="/docs/13/index.html">PostgreSQL 13</a>
                  </div>
                </div>
              </div>
              
                <div class="row">
                  <div class="col">
                    Supported Versions:
                      
                        
                        
                          <a href="/docs/current/index-locking.html" title="PostgreSQL 17 - 61.4. Index Locking Considerations" >Current</a>
                          (<a href="/docs/17/index-locking.html" title="PostgreSQL 17 - 61.4. Index Locking Considerations" >17</a>)
                        
                      
                         / 
                        
                          <a href="/docs/16/index-locking.html" title="PostgreSQL 16 - 61.4. Index Locking Considerations" >16</a>
                        
                      
                         / 
                        
                          <a href="/docs/15/index-locking.html" title="PostgreSQL 15 - 61.4. Index Locking Considerations" >15</a>
                        
                      
                         / 
                        
                          <a href="/docs/14/index-locking.html" title="PostgreSQL 14 - 61.4. Index Locking Considerations" >14</a>
                        
                      
                         / 
                        
                          <a href="/docs/13/index-locking.html" title="PostgreSQL 13 - 61.4. Index Locking Considerations" class="docs-version-selected">13</a>
                        
                      
                  </div>
                </div>
              
              
                <div class="row">
                  <div class="col">
                    Development Versions:
                    
                      
                      <a href="/docs/devel/index-locking.html" title="PostgreSQL devel - 61.4. Index Locking Considerations"  rel="nofollow">devel</a>
                    
                  </div>
                </div>
              
              
                <div class="row">
                  <div class="col-12">
                    Unsupported versions:
                    
                      
                      <a href="/docs/12/index-locking.html" title="PostgreSQL 12 - 61.4. Index Locking Considerations"  rel="nofollow">12</a>
                    
                       / 
                      <a href="/docs/11/index-locking.html" title="PostgreSQL 11 - 61.4. Index Locking Considerations"  rel="nofollow">11</a>
                    
                       / 
                      <a href="/docs/10/index-locking.html" title="PostgreSQL 10 - 61.4. Index Locking Considerations"  rel="nofollow">10</a>
                    
                       / 
                      <a href="/docs/9.6/index-locking.html" title="PostgreSQL 9.6 - 61.4. Index Locking Considerations"  rel="nofollow">9.6</a>
                    
                       / 
                      <a href="/docs/9.5/index-locking.html" title="PostgreSQL 9.5 - 61.4. Index Locking Considerations"  rel="nofollow">9.5</a>
                    
                       / 
                      <a href="/docs/9.4/index-locking.html" title="PostgreSQL 9.4 - 61.4. Index Locking Considerations"  rel="nofollow">9.4</a>
                    
                       / 
                      <a href="/docs/9.3/index-locking.html" title="PostgreSQL 9.3 - 61.4. Index Locking Considerations"  rel="nofollow">9.3</a>
                    
                       / 
                      <a href="/docs/9.2/index-locking.html" title="PostgreSQL 9.2 - 61.4. Index Locking Considerations"  rel="nofollow">9.2</a>
                    
                       / 
                      <a href="/docs/9.1/index-locking.html" title="PostgreSQL 9.1 - 61.4. Index Locking Considerations"  rel="nofollow">9.1</a>
                    
                       / 
                      <a href="/docs/9.0/index-locking.html" title="PostgreSQL 9.0 - 61.4. Index Locking Considerations"  rel="nofollow">9.0</a>
                    
                       / 
                      <a href="/docs/8.4/index-locking.html" title="PostgreSQL 8.4 - 61.4. Index Locking Considerations"  rel="nofollow">8.4</a>
                    
                       / 
                      <a href="/docs/8.3/index-locking.html" title="PostgreSQL 8.3 - 61.4. Index Locking Considerations"  rel="nofollow">8.3</a>
                    
                       / 
                      <a href="/docs/8.2/index-locking.html" title="PostgreSQL 8.2 - 61.4. Index Locking Considerations"  rel="nofollow">8.2</a>
                    
                       / 
                      <a href="/docs/8.1/index-locking.html" title="PostgreSQL 8.1 - 61.4. Index Locking Considerations"  rel="nofollow">8.1</a>
                    
                  </div>
                </div>
              
            </div>
            <div class="col-md-6 col-lg-5 offset-lg-1">
              <form id="docSearchForm" role="search" method="get" action="/search/">
                <input type="hidden" name="u" value="/docs/13/" />
                <div class="input-group">
                  <input type="text" id="q" name="q" class="form-control" placeholder="Search the documentation for..."/>
                  <span class="input-group-btn">
                    <button class="btn btn-default" type="submit"><i class="fas fa-search"></i></button>
                  </span>
                </div>
              </form>
            </div>
          </div>

          <div id="docContent">
            <div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navheader">
  <table width="100%" summary="Navigation header">
    <tr>
      <th colspan="5" align="center">61.4.&nbsp;Index Locking Considerations</th>
    </tr>
    <tr>
      <td width="10%" align="left"><a accesskey="p" href="index-scanning.html" title="61.3.&nbsp;Index Scanning">Prev</a>&nbsp;</td>
      <td width="10%" align="left"><a accesskey="u" href="indexam.html" title="Chapter&nbsp;61.&nbsp;Index Access Method Interface Definition">Up</a></td>
      <th width="60%" align="center">Chapter&nbsp;61.&nbsp;Index Access Method Interface Definition</th>
      <td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 13.20 Documentation">Home</a></td>
      <td width="10%" align="right">&nbsp;<a accesskey="n" href="index-unique-checks.html" title="61.5.&nbsp;Index Uniqueness Checks">Next</a></td>
    </tr>
  </table>
  <hr />
</div>
<div class="sect1" id="INDEX-LOCKING">
  <div class="titlepage">
    <div>
      <div>
        <h2 class="title" style="clear: both">61.4.&nbsp;Index Locking Considerations</h2>
      </div>
    </div>
  </div>
  <p>Index access methods must handle concurrent updates of the index by multiple processes. The core <span class="productname">PostgreSQL</span> system obtains <code class="literal">AccessShareLock</code> on the index during an index scan, and <code class="literal">RowExclusiveLock</code> when updating the index (including plain <code class="command">VACUUM</code>). Since these lock types do not conflict, the access method is responsible for handling any fine-grained locking it might need. An <code class="literal">ACCESS EXCLUSIVE</code> lock on the index as a whole will be taken only during index creation, destruction, or <code class="command">REINDEX</code> (<code class="literal">SHARE UPDATE EXCLUSIVE</code> is taken instead with <code class="literal">CONCURRENTLY</code>).</p>
  <p>Building an index type that supports concurrent updates usually requires extensive and subtle analysis of the required behavior. For the b-tree and hash index types, you can read about the design decisions involved in <code class="filename">src/backend/access/nbtree/README</code> and <code class="filename">src/backend/access/hash/README</code>.</p>
  <p>Aside from the index's own internal consistency requirements, concurrent updates create issues about consistency between the parent table (the <em class="firstterm">heap</em>) and the index. Because <span class="productname">PostgreSQL</span> separates accesses and updates of the heap from those of the index, there are windows in which the index might be inconsistent with the heap. We handle this problem with the following rules:</p>
  <div class="itemizedlist">
    <ul class="itemizedlist" style="list-style-type: disc;">
      <li class="listitem">
        <p>A new heap entry is made before making its index entries. (Therefore a concurrent index scan is likely to fail to see the heap entry. This is okay because the index reader would be uninterested in an uncommitted row anyway. But see <a class="xref" href="index-unique-checks.html" title="61.5.&nbsp;Index Uniqueness Checks">Section&nbsp;61.5</a>.)</p>
      </li>
      <li class="listitem">
        <p>When a heap entry is to be deleted (by <code class="command">VACUUM</code>), all its index entries must be removed first.</p>
      </li>
      <li class="listitem">
        <p>An index scan must maintain a pin on the index page holding the item last returned by <code class="function">amgettuple</code>, and <code class="function">ambulkdelete</code> cannot delete entries from pages that are pinned by other backends. The need for this rule is explained below.</p>
      </li>
    </ul>
  </div>
  <p>Without the third rule, it is possible for an index reader to see an index entry just before it is removed by <code class="command">VACUUM</code>, and then to arrive at the corresponding heap entry after that was removed by <code class="command">VACUUM</code>. This creates no serious problems if that item number is still unused when the reader reaches it, since an empty item slot will be ignored by <code class="function">heap_fetch()</code>. But what if a third backend has already re-used the item slot for something else? When using an MVCC-compliant snapshot, there is no problem because the new occupant of the slot is certain to be too new to pass the snapshot test. However, with a non-MVCC-compliant snapshot (such as <code class="literal">SnapshotAny</code>), it would be possible to accept and return a row that does not in fact match the scan keys. We could defend against this scenario by requiring the scan keys to be rechecked against the heap row in all cases, but that is too expensive. Instead, we use a pin on an index page as a proxy to indicate that the reader might still be <span class="quote">“<span class="quote">in flight</span>”</span> from the index entry to the matching heap entry. Making <code class="function">ambulkdelete</code> block on such a pin ensures that <code class="command">VACUUM</code> cannot delete the heap entry before the reader is done with it. This solution costs little in run time, and adds blocking overhead only in the rare cases where there actually is a conflict.</p>
  <p>This solution requires that index scans be <span class="quote">“<span class="quote">synchronous</span>”</span>: we have to fetch each heap tuple immediately after scanning the corresponding index entry. This is expensive for a number of reasons. An <span class="quote">“<span class="quote">asynchronous</span>”</span> scan in which we collect many TIDs from the index, and only visit the heap tuples sometime later, requires much less index locking overhead and can allow a more efficient heap access pattern. Per the above analysis, we must use the synchronous approach for non-MVCC-compliant snapshots, but an asynchronous scan is workable for a query using an MVCC snapshot.</p>
  <p>In an <code class="function">amgetbitmap</code> index scan, the access method does not keep an index pin on any of the returned tuples. Therefore it is only safe to use such scans with MVCC-compliant snapshots.</p>
  <p>When the <code class="structfield">ampredlocks</code> flag is not set, any scan using that index access method within a serializable transaction will acquire a nonblocking predicate lock on the full index. This will generate a read-write conflict with the insert of any tuple into that index by a concurrent serializable transaction. If certain patterns of read-write conflicts are detected among a set of concurrent serializable transactions, one of those transactions may be canceled to protect data integrity. When the flag is set, it indicates that the index access method implements finer-grained predicate locking, which will tend to reduce the frequency of such transaction cancellations.</p>
</div>
<div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navfooter">
  <hr />
  <table width="100%" summary="Navigation footer">
    <tr>
      <td width="40%" align="left"><a accesskey="p" href="index-scanning.html" title="61.3.&nbsp;Index Scanning">Prev</a>&nbsp;</td>
      <td width="20%" align="center"><a accesskey="u" href="indexam.html" title="Chapter&nbsp;61.&nbsp;Index Access Method Interface Definition">Up</a></td>
      <td width="40%" align="right">&nbsp;<a accesskey="n" href="index-unique-checks.html" title="61.5.&nbsp;Index Uniqueness Checks">Next</a></td>
    </tr>
    <tr>
      <td width="40%" align="left" valign="top">61.3.&nbsp;Index Scanning&nbsp;</td>
      <td width="20%" align="center"><a accesskey="h" href="index.html" title="PostgreSQL 13.20 Documentation">Home</a></td>
      <td width="40%" align="right" valign="top">&nbsp;61.5.&nbsp;Index Uniqueness Checks</td>
    </tr>
  </table>
</div>

          </div>
          
            <div id="docComments">
              <h2>Submit correction</h2>
              <p>
              If you see anything in the documentation that is not correct, does not match
              your experience with the particular feature or requires further clarification,
              please use
              <a href="/account/comments/new/13/index-locking.html/" rel="nofollow">this form</a>
              to report a documentation issue.
              </p>
            </div>
          
        </div> 
      </div>
    </div>
    
    
    
    
    
    
  </body>
</html>
