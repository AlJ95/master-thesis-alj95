<!doctype html><html itemscope itemtype=http://schema.org/WebPage lang=en class=no-js><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Transport security model | etcd</title>
<meta name=description content="Securing data in transit"><meta property="og:url" content="https://etcd.io/docs/v3.5/op-guide/security/"><meta property="og:site_name" content="etcd"><meta property="og:title" content="Transport security model"><meta property="og:description" content="Securing data in transit"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="docs"><meta property="article:modified_time" content="2023-10-25T09:16:40+01:00"><meta itemprop=name content="Transport security model"><meta itemprop=description content="Securing data in transit"><meta itemprop=dateModified content="2023-10-25T09:16:40+01:00"><meta itemprop=wordCount content="3074"><meta name=twitter:card content="summary"><meta name=twitter:title content="Transport security model"><meta name=twitter:description content="Securing data in transit"></head><body class=td-page><div class="container-fluid td-outer"><div class=td-main><div class="row flex-xl-nowrap"><main class="col-12 col-md-9 col-xl-8 ps-md-5" role=main><div class=td-content><h1>Transport security model</h1><div class=lead>Securing data in transit</div><p>etcd supports automatic TLS as well as authentication through client certificates for both clients to server as well as peer (server to server / cluster) communication. <strong>Note that etcd doesn&rsquo;t enable <a href=../authentication/>RBAC based authentication</a> or the authentication feature in the transport layer by default to reduce friction for users getting started with the database. Further, changing this default would be a breaking change for the project which was established since 2013. An etcd cluster which doesn&rsquo;t enable security features can expose its data to any clients.</strong></p><p>To get up and running, first have a CA certificate and a signed key pair for one member. It is recommended to create and sign a new key pair for every member in a cluster.</p><p>For convenience, the <a href=https://github.com/cloudflare/cfssl target=_blank rel=noopener>cfssl</a> tool provides an easy interface to certificate generation, and we provide an example using the tool <a href=https://github.com/etcd-io/etcd/tree/master/hack/tls-setup target=_blank rel=noopener>here</a>. Alternatively, try this <a href=https://github.com/coreos/docs/blob/master/os/generate-self-signed-certificates.md target=_blank rel=noopener>guide to generating self-signed key pairs</a>.</p><h2 id=basic-setup>Basic setup</h2><p>etcd takes several certificate related configuration options, either through command-line flags or environment variables:</p><p><strong>Client-to-server communication:</strong></p><p><code>--cert-file=&lt;path></code>: Certificate used for SSL/TLS connections <strong>to</strong> etcd. When this option is set, advertise-client-urls can use the HTTPS schema.</p><p><code>--key-file=&lt;path></code>: Key for the certificate. Must be unencrypted.</p><p><code>--client-cert-auth</code>: When this is set etcd will check all incoming HTTPS requests for a client certificate signed by the trusted CA, requests that don&rsquo;t supply a valid client certificate will fail. If <a href=../authentication/>authentication</a> is enabled, the certificate provides credentials for the user name given by the Common Name field.</p><p><code>--trusted-ca-file=&lt;path></code>: Trusted certificate authority.</p><p><code>--auto-tls</code>: Use automatically generated self-signed certificates for TLS connections with clients.</p><p><strong>Peer (server-to-server / cluster) communication:</strong></p><p>The peer options work the same way as the client-to-server options:</p><p><code>--peer-cert-file=&lt;path></code>: Certificate used for SSL/TLS connections between peers. This will be used both for listening on the peer address as well as sending requests to other peers.</p><p><code>--peer-key-file=&lt;path></code>: Key for the certificate. Must be unencrypted.</p><p><code>--peer-client-cert-auth</code>: When set, etcd will check all incoming peer requests from the cluster for valid client certificates signed by the supplied CA.</p><p><code>--peer-trusted-ca-file=&lt;path></code>: Trusted certificate authority.</p><p><code>--peer-auto-tls</code>: Use automatically generated self-signed certificates for TLS connections between peers.</p><p>If either a client-to-server or peer certificate is supplied the key must also be set. All of these configuration options are also available through the environment variables, <code>ETCD_CA_FILE</code>, <code>ETCD_PEER_CA_FILE</code> and so on.</p><p><strong>Common options:</strong></p><p><code>--cipher-suites</code>: Comma-separated list of supported TLS cipher suites between server/client and peers (empty will be auto-populated by Go).</p><p><code>--tls-min-version=&lt;version></code> Sets the minimum TLS version supported by etcd.</p><p><code>--tls-max-version=&lt;version></code> Sets the maximum TLS version supported by etcd. If not set the maximum version supported by Go will be used.</p><h2 id=example-1-client-to-server-transport-security-with-https>Example 1: Client-to-server transport security with HTTPS</h2><p>For this, have a CA certificate (<code>ca.crt</code>) and signed key pair (<code>server.crt</code>, <code>server.key</code>) ready.</p><p>Let us configure etcd to provide simple HTTPS transport security step by step:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>$ etcd --name infra0 --data-dir infra0 <span style=color:#4e9a06>\
</span></span></span><span style=display:flex><span><span style=color:#4e9a06></span>  --cert-file<span style=color:#ce5c00;font-weight:700>=</span>/path/to/server.crt --key-file<span style=color:#ce5c00;font-weight:700>=</span>/path/to/server.key <span style=color:#4e9a06>\
</span></span></span><span style=display:flex><span><span style=color:#4e9a06></span>  --advertise-client-urls<span style=color:#ce5c00;font-weight:700>=</span>https://127.0.0.1:2379 --listen-client-urls<span style=color:#ce5c00;font-weight:700>=</span>https://127.0.0.1:2379
</span></span></code></pre></div><p>This should start up fine and it will be possible to test the configuration by speaking HTTPS to etcd:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>$ curl --cacert /path/to/ca.crt https://127.0.0.1:2379/v2/keys/foo -XPUT -d <span style=color:#000>value</span><span style=color:#ce5c00;font-weight:700>=</span>bar -v
</span></span></code></pre></div><p>The command should show that the handshake succeed. Since we use self-signed certificates with our own certificate authority, the CA must be passed to curl using the <code>--cacert</code> option. Another possibility would be to add the CA certificate to the system&rsquo;s trusted certificates directory (usually in <code>/etc/pki/tls/certs</code> or <code>/etc/ssl/certs</code>).</p><p><strong>OSX 10.9+ Users</strong>: curl 7.30.0 on OSX 10.9+ doesn&rsquo;t understand certificates passed in on the command line.
Instead, import the dummy ca.crt directly into the keychain or add the <code>-k</code> flag to curl to ignore errors.
To test without the <code>-k</code> flag, run <code>open ./tests/fixtures/ca/ca.crt</code> and follow the prompts.
Please remove this certificate after testing!
If there is a workaround, let us know.</p><h2 id=example-2-client-to-server-authentication-with-https-client-certificates>Example 2: Client-to-server authentication with HTTPS client certificates</h2><p>For now we&rsquo;ve given the etcd client the ability to verify the server identity and provide transport security. We can however also use client certificates to prevent unauthorized access to etcd.</p><p>The clients will provide their certificates to the server and the server will check whether the cert is signed by the supplied CA and decide whether to serve the request.</p><p>The same files mentioned in the first example are needed for this, as well as a key pair for the client (<code>client.crt</code>, <code>client.key</code>) signed by the same certificate authority.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>$ etcd --name infra0 --data-dir infra0 <span style=color:#4e9a06>\
</span></span></span><span style=display:flex><span><span style=color:#4e9a06></span>  --client-cert-auth --trusted-ca-file<span style=color:#ce5c00;font-weight:700>=</span>/path/to/ca.crt --cert-file<span style=color:#ce5c00;font-weight:700>=</span>/path/to/server.crt --key-file<span style=color:#ce5c00;font-weight:700>=</span>/path/to/server.key <span style=color:#4e9a06>\
</span></span></span><span style=display:flex><span><span style=color:#4e9a06></span>  --advertise-client-urls https://127.0.0.1:2379 --listen-client-urls https://127.0.0.1:2379
</span></span></code></pre></div><p>Now try the same request as above to this server:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>$ curl --cacert /path/to/ca.crt https://127.0.0.1:2379/v2/keys/foo -XPUT -d <span style=color:#000>value</span><span style=color:#ce5c00;font-weight:700>=</span>bar -v
</span></span></code></pre></div><p>The request should be rejected by the server:</p><pre tabindex=0><code>...
routines:SSL3_READ_BYTES:sslv3 alert bad certificate
...
</code></pre><p>To make it succeed, we need to give the CA signed client certificate to the server:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>$ curl --cacert /path/to/ca.crt --cert /path/to/client.crt --key /path/to/client.key <span style=color:#4e9a06>\
</span></span></span><span style=display:flex><span><span style=color:#4e9a06></span>  -L https://127.0.0.1:2379/v2/keys/foo -XPUT -d <span style=color:#000>value</span><span style=color:#ce5c00;font-weight:700>=</span>bar -v
</span></span></code></pre></div><p>The output should include:</p><pre tabindex=0><code>...
SSLv3, TLS handshake, CERT verify (15):
...
TLS handshake, Finished (20)
</code></pre><p>And also the response from the server:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span><span style=color:#000;font-weight:700>{</span>
</span></span><span style=display:flex><span>    <span style=color:#204a87;font-weight:700>&#34;action&#34;</span><span style=color:#000;font-weight:700>:</span> <span style=color:#4e9a06>&#34;set&#34;</span><span style=color:#000;font-weight:700>,</span>
</span></span><span style=display:flex><span>    <span style=color:#204a87;font-weight:700>&#34;node&#34;</span><span style=color:#000;font-weight:700>:</span> <span style=color:#000;font-weight:700>{</span>
</span></span><span style=display:flex><span>        <span style=color:#204a87;font-weight:700>&#34;createdIndex&#34;</span><span style=color:#000;font-weight:700>:</span> <span style=color:#0000cf;font-weight:700>12</span><span style=color:#000;font-weight:700>,</span>
</span></span><span style=display:flex><span>        <span style=color:#204a87;font-weight:700>&#34;key&#34;</span><span style=color:#000;font-weight:700>:</span> <span style=color:#4e9a06>&#34;/foo&#34;</span><span style=color:#000;font-weight:700>,</span>
</span></span><span style=display:flex><span>        <span style=color:#204a87;font-weight:700>&#34;modifiedIndex&#34;</span><span style=color:#000;font-weight:700>:</span> <span style=color:#0000cf;font-weight:700>12</span><span style=color:#000;font-weight:700>,</span>
</span></span><span style=display:flex><span>        <span style=color:#204a87;font-weight:700>&#34;value&#34;</span><span style=color:#000;font-weight:700>:</span> <span style=color:#4e9a06>&#34;bar&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#000;font-weight:700>}</span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>}</span>
</span></span></code></pre></div><p>Specify cipher suites to block <a href=https://github.com/etcd-io/etcd/issues/8320 target=_blank rel=noopener>weak TLS cipher suites</a>.</p><p>TLS handshake would fail when client hello is requested with invalid cipher suites.</p><p>For instance:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ etcd <span style=color:#4e9a06>\
</span></span></span><span style=display:flex><span><span style=color:#4e9a06></span>  --cert-file ./server.crt <span style=color:#4e9a06>\
</span></span></span><span style=display:flex><span><span style=color:#4e9a06></span>  --key-file ./server.key <span style=color:#4e9a06>\
</span></span></span><span style=display:flex><span><span style=color:#4e9a06></span>  --trusted-ca-file ./ca.crt <span style=color:#4e9a06>\
</span></span></span><span style=display:flex><span><span style=color:#4e9a06></span>  --cipher-suites TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384
</span></span></code></pre></div><p>Then, client requests must specify one of the cipher suites specified in the server:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#8f5902;font-style:italic># valid cipher suite</span>
</span></span><span style=display:flex><span>$ curl <span style=color:#4e9a06>\
</span></span></span><span style=display:flex><span><span style=color:#4e9a06></span>  --cacert /path/to/ca.crt <span style=color:#4e9a06>\
</span></span></span><span style=display:flex><span><span style=color:#4e9a06></span>  --cert /path/to/client.crt <span style=color:#4e9a06>\
</span></span></span><span style=display:flex><span><span style=color:#4e9a06></span>  --key /path/to/client.key <span style=color:#4e9a06>\
</span></span></span><span style=display:flex><span><span style=color:#4e9a06></span>  -L <span style=color:#ce5c00;font-weight:700>[</span>CLIENT-URL<span style=color:#ce5c00;font-weight:700>]</span>/metrics <span style=color:#4e9a06>\
</span></span></span><span style=display:flex><span><span style=color:#4e9a06></span>  --ciphers ECDHE-RSA-AES128-GCM-SHA256
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic># request succeeds</span>
</span></span><span style=display:flex><span>etcd_server_version<span style=color:#ce5c00;font-weight:700>{</span><span style=color:#000>server_version</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#4e9a06>&#34;3.2.22&#34;</span><span style=color:#ce5c00;font-weight:700>}</span> <span style=color:#0000cf;font-weight:700>1</span>
</span></span><span style=display:flex><span>...
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#8f5902;font-style:italic># invalid cipher suite</span>
</span></span><span style=display:flex><span>$ curl <span style=color:#4e9a06>\
</span></span></span><span style=display:flex><span><span style=color:#4e9a06></span>  --cacert /path/to/ca.crt <span style=color:#4e9a06>\
</span></span></span><span style=display:flex><span><span style=color:#4e9a06></span>  --cert /path/to/client.crt <span style=color:#4e9a06>\
</span></span></span><span style=display:flex><span><span style=color:#4e9a06></span>  --key /path/to/client.key <span style=color:#4e9a06>\
</span></span></span><span style=display:flex><span><span style=color:#4e9a06></span>  -L <span style=color:#ce5c00;font-weight:700>[</span>CLIENT-URL<span style=color:#ce5c00;font-weight:700>]</span>/metrics <span style=color:#4e9a06>\
</span></span></span><span style=display:flex><span><span style=color:#4e9a06></span>  --ciphers ECDHE-RSA-DES-CBC3-SHA
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic># request fails with</span>
</span></span><span style=display:flex><span><span style=color:#ce5c00;font-weight:700>(</span>35<span style=color:#ce5c00;font-weight:700>)</span> error:14094410:SSL routines:ssl3_read_bytes:sslv3 alert handshake failure
</span></span></code></pre></div><h2 id=example-3-transport-security--client-certificates-in-a-cluster>Example 3: Transport security & client certificates in a cluster</h2><p>etcd supports the same model as above for <strong>peer communication</strong>, that means the communication between etcd members in a cluster.</p><p>Assuming we have our <code>ca.crt</code> and two members with their own key pairs (<code>member1.crt</code> & <code>member1.key</code>, <code>member2.crt</code> & <code>member2.key</code>) signed by this CA, we launch etcd as follows:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span><span style=color:#000>DISCOVERY_URL</span><span style=color:#ce5c00;font-weight:700>=</span>... <span style=color:#8f5902;font-style:italic># from https://discovery.etcd.io/new</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic># member1</span>
</span></span><span style=display:flex><span>$ etcd --name infra1 --data-dir infra1 <span style=color:#4e9a06>\
</span></span></span><span style=display:flex><span><span style=color:#4e9a06></span>  --peer-client-cert-auth --peer-trusted-ca-file<span style=color:#ce5c00;font-weight:700>=</span>/path/to/ca.crt --peer-cert-file<span style=color:#ce5c00;font-weight:700>=</span>/path/to/member1.crt --peer-key-file<span style=color:#ce5c00;font-weight:700>=</span>/path/to/member1.key <span style=color:#4e9a06>\
</span></span></span><span style=display:flex><span><span style=color:#4e9a06></span>  --initial-advertise-peer-urls<span style=color:#ce5c00;font-weight:700>=</span>https://10.0.1.10:2380 --listen-peer-urls<span style=color:#ce5c00;font-weight:700>=</span>https://10.0.1.10:2380 <span style=color:#4e9a06>\
</span></span></span><span style=display:flex><span><span style=color:#4e9a06></span>  --discovery <span style=color:#4e9a06>${</span><span style=color:#000>DISCOVERY_URL</span><span style=color:#4e9a06>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic># member2</span>
</span></span><span style=display:flex><span>$ etcd --name infra2 --data-dir infra2 <span style=color:#4e9a06>\
</span></span></span><span style=display:flex><span><span style=color:#4e9a06></span>  --peer-client-cert-auth --peer-trusted-ca-file<span style=color:#ce5c00;font-weight:700>=</span>/path/to/ca.crt --peer-cert-file<span style=color:#ce5c00;font-weight:700>=</span>/path/to/member2.crt --peer-key-file<span style=color:#ce5c00;font-weight:700>=</span>/path/to/member2.key <span style=color:#4e9a06>\
</span></span></span><span style=display:flex><span><span style=color:#4e9a06></span>  --initial-advertise-peer-urls<span style=color:#ce5c00;font-weight:700>=</span>https://10.0.1.11:2380 --listen-peer-urls<span style=color:#ce5c00;font-weight:700>=</span>https://10.0.1.11:2380 <span style=color:#4e9a06>\
</span></span></span><span style=display:flex><span><span style=color:#4e9a06></span>  --discovery <span style=color:#4e9a06>${</span><span style=color:#000>DISCOVERY_URL</span><span style=color:#4e9a06>}</span>
</span></span></code></pre></div><p>The etcd members will form a cluster and all communication between members in the cluster will be encrypted and authenticated using the client certificates. The output of etcd will show that the addresses it connects to use HTTPS.</p><h2 id=example-4-automatic-self-signed-transport-security>Example 4: Automatic self-signed transport security</h2><p><strong>NOTE:</strong> When you specify ClientAutoTLS and PeerAutoTLS, the validity period of the client certificate and peer certificate automatically generated by etcd is only 1 year. You can specify the --self-signed-cert-validity flag to set the validity period of the certificate in years.</p><p>For cases where communication encryption, but not authentication, is needed, etcd supports encrypting its messages with automatically generated self-signed certificates. This simplifies deployment because there is no need for managing certificates and keys outside of etcd.
Configure etcd to use self-signed certificates for client and peer connections with the flags <code>--auto-tls</code> and <code>--peer-auto-tls</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span><span style=color:#000>DISCOVERY_URL</span><span style=color:#ce5c00;font-weight:700>=</span>... <span style=color:#8f5902;font-style:italic># from https://discovery.etcd.io/new</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic># member1</span>
</span></span><span style=display:flex><span>$ etcd --name infra1 --data-dir infra1 <span style=color:#4e9a06>\
</span></span></span><span style=display:flex><span><span style=color:#4e9a06></span>  --auto-tls --peer-auto-tls <span style=color:#4e9a06>\
</span></span></span><span style=display:flex><span><span style=color:#4e9a06></span>  --initial-advertise-peer-urls<span style=color:#ce5c00;font-weight:700>=</span>https://10.0.1.10:2380 --listen-peer-urls<span style=color:#ce5c00;font-weight:700>=</span>https://10.0.1.10:2380 <span style=color:#4e9a06>\
</span></span></span><span style=display:flex><span><span style=color:#4e9a06></span>  --discovery <span style=color:#4e9a06>${</span><span style=color:#000>DISCOVERY_URL</span><span style=color:#4e9a06>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic># member2</span>
</span></span><span style=display:flex><span>$ etcd --name infra2 --data-dir infra2 <span style=color:#4e9a06>\
</span></span></span><span style=display:flex><span><span style=color:#4e9a06></span>  --auto-tls --peer-auto-tls <span style=color:#4e9a06>\
</span></span></span><span style=display:flex><span><span style=color:#4e9a06></span>  --initial-advertise-peer-urls<span style=color:#ce5c00;font-weight:700>=</span>https://10.0.1.11:2380 --listen-peer-urls<span style=color:#ce5c00;font-weight:700>=</span>https://10.0.1.11:2380 <span style=color:#4e9a06>\
</span></span></span><span style=display:flex><span><span style=color:#4e9a06></span>  --discovery <span style=color:#4e9a06>${</span><span style=color:#000>DISCOVERY_URL</span><span style=color:#4e9a06>}</span>
</span></span></code></pre></div><p>Self-signed certificates do not authenticate identity so curl will return an error:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>curl: <span style=color:#ce5c00;font-weight:700>(</span>60<span style=color:#ce5c00;font-weight:700>)</span> SSL certificate problem: Invalid certificate chain
</span></span></code></pre></div><p>To disable certificate chain checking, invoke curl with the <code>-k</code> flag:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>$ curl -k https://127.0.0.1:2379/v2/keys/foo -Xput -d <span style=color:#000>value</span><span style=color:#ce5c00;font-weight:700>=</span>bar -v
</span></span></code></pre></div><h2 id=notes-for-dns-srv>Notes for DNS SRV</h2><p>Since v3.1.0 (except v3.2.9), discovery SRV bootstrapping authenticates <code>ServerName</code> with a root domain name from <code>--discovery-srv</code> flag. This is to avoid man-in-the-middle cert attacks, by requiring a certificate to have matching root domain name in its Subject Alternative Name (SAN) field. For instance, <code>etcd --discovery-srv=etcd.local</code> will only authenticate peers/clients when the provided certs have root domain <code>etcd.local</code> as an entry in Subject Alternative Name (SAN) field</p><h2 id=notes-for-etcd-proxy>Notes for etcd proxy</h2><p>etcd proxy terminates the TLS from its client if the connection is secure, and uses proxy&rsquo;s own key/cert specified in <code>--peer-key-file</code> and <code>--peer-cert-file</code> to communicate with etcd members.</p><p>The proxy communicates with etcd members through both the <code>--advertise-client-urls</code> and <code>--advertise-peer-urls</code> of a given member. It forwards client requests to etcd members’ advertised client urls, and it syncs the initial cluster configuration through etcd members’ advertised peer urls.</p><p>When client authentication is enabled for an etcd member, the administrator must ensure that the peer certificate specified in the proxy&rsquo;s <code>--peer-cert-file</code> option is valid for that authentication. The proxy&rsquo;s peer certificate must also be valid for peer authentication if peer authentication is enabled.</p><h2 id=notes-for-tls-authentication>Notes for TLS authentication</h2><p>Since <a href=https://github.com/etcd-io/etcd/blob/master/CHANGELOG-3.2.md#v320-2017-06-09 target=_blank rel=noopener>v3.2.0</a>, <a href=https://github.com/etcd-io/etcd/pull/7829 target=_blank rel=noopener>TLS certificates get reloaded on every client connection</a>. This is useful when replacing expiry certs without stopping etcd servers; it can be done by overwriting old certs with new ones. Refreshing certs for every connection should not have too much overhead, but can be improved in the future, with caching layer. Example tests can be found <a href=https://github.com/etcd-io/etcd/blob/b041ce5d514a4b4aaeefbffb008f0c7570a18986/integration/v3_grpc_test.go#L1601-L1757 target=_blank rel=noopener>here</a>.</p><p>Since <a href=https://github.com/etcd-io/etcd/blob/master/CHANGELOG-3.2.md#v320-2017-06-09 target=_blank rel=noopener>v3.2.0</a>, <a href=https://github.com/etcd-io/etcd/pull/7687 target=_blank rel=noopener>server denies incoming peer certs with wrong IP <code>SAN</code></a>. For instance, if peer cert contains any IP addresses in Subject Alternative Name (SAN) field, server authenticates a peer only when the remote IP address matches one of those IP addresses. This is to prevent unauthorized endpoints from joining the cluster. For example, peer B&rsquo;s CSR (with <code>cfssl</code>) is:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span><span style=color:#000;font-weight:700>{</span>
</span></span><span style=display:flex><span>  <span style=color:#204a87;font-weight:700>&#34;CN&#34;</span><span style=color:#000;font-weight:700>:</span> <span style=color:#4e9a06>&#34;etcd peer&#34;</span><span style=color:#000;font-weight:700>,</span>
</span></span><span style=display:flex><span>  <span style=color:#204a87;font-weight:700>&#34;hosts&#34;</span><span style=color:#000;font-weight:700>:</span> <span style=color:#000;font-weight:700>[</span>
</span></span><span style=display:flex><span>    <span style=color:#4e9a06>&#34;*.example.default.svc&#34;</span><span style=color:#000;font-weight:700>,</span>
</span></span><span style=display:flex><span>    <span style=color:#4e9a06>&#34;*.example.default.svc.cluster.local&#34;</span><span style=color:#000;font-weight:700>,</span>
</span></span><span style=display:flex><span>    <span style=color:#4e9a06>&#34;10.138.0.27&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#000;font-weight:700>],</span>
</span></span><span style=display:flex><span>  <span style=color:#204a87;font-weight:700>&#34;key&#34;</span><span style=color:#000;font-weight:700>:</span> <span style=color:#000;font-weight:700>{</span>
</span></span><span style=display:flex><span>    <span style=color:#204a87;font-weight:700>&#34;algo&#34;</span><span style=color:#000;font-weight:700>:</span> <span style=color:#4e9a06>&#34;rsa&#34;</span><span style=color:#000;font-weight:700>,</span>
</span></span><span style=display:flex><span>    <span style=color:#204a87;font-weight:700>&#34;size&#34;</span><span style=color:#000;font-weight:700>:</span> <span style=color:#0000cf;font-weight:700>2048</span>
</span></span><span style=display:flex><span>  <span style=color:#000;font-weight:700>},</span>
</span></span><span style=display:flex><span>  <span style=color:#204a87;font-weight:700>&#34;names&#34;</span><span style=color:#000;font-weight:700>:</span> <span style=color:#000;font-weight:700>[</span>
</span></span><span style=display:flex><span>    <span style=color:#000;font-weight:700>{</span>
</span></span><span style=display:flex><span>      <span style=color:#204a87;font-weight:700>&#34;C&#34;</span><span style=color:#000;font-weight:700>:</span> <span style=color:#4e9a06>&#34;US&#34;</span><span style=color:#000;font-weight:700>,</span>
</span></span><span style=display:flex><span>      <span style=color:#204a87;font-weight:700>&#34;L&#34;</span><span style=color:#000;font-weight:700>:</span> <span style=color:#4e9a06>&#34;CA&#34;</span><span style=color:#000;font-weight:700>,</span>
</span></span><span style=display:flex><span>      <span style=color:#204a87;font-weight:700>&#34;ST&#34;</span><span style=color:#000;font-weight:700>:</span> <span style=color:#4e9a06>&#34;San Francisco&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#000;font-weight:700>}</span>
</span></span><span style=display:flex><span>  <span style=color:#000;font-weight:700>]</span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>}</span>
</span></span></code></pre></div><p>when peer B&rsquo;s actual IP address is <code>10.138.0.2</code>, not <code>10.138.0.27</code>. When peer B tries to join the cluster, peer A will reject B with the error <code>x509: certificate is valid for 10.138.0.27, not 10.138.0.2</code>, because B&rsquo;s remote IP address does not match the one in Subject Alternative Name (SAN) field.</p><p>Since <a href=https://github.com/etcd-io/etcd/blob/master/CHANGELOG-3.2.md#v320-2017-06-09 target=_blank rel=noopener>v3.2.0</a>, <a href=https://github.com/etcd-io/etcd/pull/7767 target=_blank rel=noopener>server resolves TLS <code>DNSNames</code> when checking <code>SAN</code></a>. For instance, if peer cert contains only DNS names (no IP addresses) in Subject Alternative Name (SAN) field, server authenticates a peer only when forward-lookups (<code>dig b.com</code>) on those DNS names have matching IP with the remote IP address. For example, peer B&rsquo;s CSR (with <code>cfssl</code>) is:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span><span style=color:#000;font-weight:700>{</span>
</span></span><span style=display:flex><span>  <span style=color:#204a87;font-weight:700>&#34;CN&#34;</span><span style=color:#000;font-weight:700>:</span> <span style=color:#4e9a06>&#34;etcd peer&#34;</span><span style=color:#000;font-weight:700>,</span>
</span></span><span style=display:flex><span>  <span style=color:#204a87;font-weight:700>&#34;hosts&#34;</span><span style=color:#000;font-weight:700>:</span> <span style=color:#000;font-weight:700>[</span>
</span></span><span style=display:flex><span>    <span style=color:#4e9a06>&#34;b.com&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#000;font-weight:700>],</span>
</span></span></code></pre></div><p>when peer B&rsquo;s remote IP address is <code>10.138.0.2</code>. When peer B tries to join the cluster, peer A looks up the incoming host <code>b.com</code> to get the list of IP addresses (e.g. <code>dig b.com</code>). And rejects B if the list does not contain the IP <code>10.138.0.2</code>, with the error <code>tls: 10.138.0.2 does not match any of DNSNames ["b.com"]</code>.</p><p>Since <a href=https://github.com/etcd-io/etcd/blob/master/CHANGELOG-3.2.md#v322-2017-07-07 target=_blank rel=noopener>v3.2.2</a>, <a href=https://github.com/etcd-io/etcd/pull/8223 target=_blank rel=noopener>server accepts connections if IP matches, without checking DNS entries</a>. For instance, if peer cert contains IP addresses and DNS names in Subject Alternative Name (SAN) field, and the remote IP address matches one of those IP addresses, server just accepts connection without further checking the DNS names. For example, peer B&rsquo;s CSR (with <code>cfssl</code>) is:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span><span style=color:#000;font-weight:700>{</span>
</span></span><span style=display:flex><span>  <span style=color:#204a87;font-weight:700>&#34;CN&#34;</span><span style=color:#000;font-weight:700>:</span> <span style=color:#4e9a06>&#34;etcd peer&#34;</span><span style=color:#000;font-weight:700>,</span>
</span></span><span style=display:flex><span>  <span style=color:#204a87;font-weight:700>&#34;hosts&#34;</span><span style=color:#000;font-weight:700>:</span> <span style=color:#000;font-weight:700>[</span>
</span></span><span style=display:flex><span>    <span style=color:#4e9a06>&#34;invalid.domain&#34;</span><span style=color:#000;font-weight:700>,</span>
</span></span><span style=display:flex><span>    <span style=color:#4e9a06>&#34;10.138.0.2&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#000;font-weight:700>],</span>
</span></span></code></pre></div><p>when peer B&rsquo;s remote IP address is <code>10.138.0.2</code> and <code>invalid.domain</code> is a invalid host. When peer B tries to join the cluster, peer A successfully authenticates B, since Subject Alternative Name (SAN) field has a valid matching IP address. See <a href=https://github.com/etcd-io/etcd/issues/8206 target=_blank rel=noopener>issue#8206</a> for more detail.</p><p>Since <a href=https://github.com/etcd-io/etcd/blob/master/CHANGELOG-3.2.md#v325-2017-08-04 target=_blank rel=noopener>v3.2.5</a>, <a href=https://github.com/etcd-io/etcd/pull/8281 target=_blank rel=noopener>server supports reverse-lookup on wildcard DNS <code>SAN</code></a>. For instance, if peer cert contains only DNS names (no IP addresses) in Subject Alternative Name (SAN) field, server first reverse-lookups the remote IP address to get a list of names mapping to that address (e.g. <code>nslookup IPADDR</code>). Then accepts the connection if those names have a matching name with peer cert&rsquo;s DNS names (either by exact or wildcard match). If none is matched, server forward-lookups each DNS entry in peer cert (e.g. look up <code>example.default.svc</code> when the entry is <code>*.example.default.svc</code>), and accepts connection only when the host&rsquo;s resolved addresses have the matching IP address with the peer&rsquo;s remote IP address. For example, peer B&rsquo;s CSR (with <code>cfssl</code>) is:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span><span style=color:#000;font-weight:700>{</span>
</span></span><span style=display:flex><span>  <span style=color:#204a87;font-weight:700>&#34;CN&#34;</span><span style=color:#000;font-weight:700>:</span> <span style=color:#4e9a06>&#34;etcd peer&#34;</span><span style=color:#000;font-weight:700>,</span>
</span></span><span style=display:flex><span>  <span style=color:#204a87;font-weight:700>&#34;hosts&#34;</span><span style=color:#000;font-weight:700>:</span> <span style=color:#000;font-weight:700>[</span>
</span></span><span style=display:flex><span>    <span style=color:#4e9a06>&#34;*.example.default.svc&#34;</span><span style=color:#000;font-weight:700>,</span>
</span></span><span style=display:flex><span>    <span style=color:#4e9a06>&#34;*.example.default.svc.cluster.local&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#000;font-weight:700>],</span>
</span></span></code></pre></div><p>when peer B&rsquo;s remote IP address is <code>10.138.0.2</code>. When peer B tries to join the cluster, peer A reverse-lookup the IP <code>10.138.0.2</code> to get the list of host names. And either exact or wildcard match the host names with peer B&rsquo;s cert DNS names in Subject Alternative Name (SAN) field. If none of reverse/forward lookups worked, it returns an error <code>"tls: "10.138.0.2" does not match any of DNSNames ["*.example.default.svc","*.example.default.svc.cluster.local"]</code>. See <a href=https://github.com/etcd-io/etcd/issues/8268 target=_blank rel=noopener>issue#8268</a> for more detail.</p><p><a href=https://github.com/etcd-io/etcd/blob/master/CHANGELOG-3.3.md target=_blank rel=noopener>v3.3.0</a> adds <a href=https://github.com/etcd-io/etcd/pull/8616 target=_blank rel=noopener><code>etcd --peer-cert-allowed-cn</code></a> flag to support <a href=https://github.com/etcd-io/etcd/issues/8262 target=_blank rel=noopener>CN(Common Name)-based auth for inter-peer connections</a>. Kubernetes TLS bootstrapping involves generating dynamic certificates for etcd members and other system components (e.g. API server, kubelet, etc.). Maintaining different CAs for each component provides tighter access control to etcd cluster but often tedious. When <code>--peer-cert-allowed-cn</code> flag is specified, node can only join with matching common name even with shared CAs. For example, each member in 3-node cluster is set up with CSRs (with <code>cfssl</code>) as below:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span><span style=color:#000;font-weight:700>{</span>
</span></span><span style=display:flex><span>  <span style=color:#204a87;font-weight:700>&#34;CN&#34;</span><span style=color:#000;font-weight:700>:</span> <span style=color:#4e9a06>&#34;etcd.local&#34;</span><span style=color:#000;font-weight:700>,</span>
</span></span><span style=display:flex><span>  <span style=color:#204a87;font-weight:700>&#34;hosts&#34;</span><span style=color:#000;font-weight:700>:</span> <span style=color:#000;font-weight:700>[</span>
</span></span><span style=display:flex><span>    <span style=color:#4e9a06>&#34;m1.etcd.local&#34;</span><span style=color:#000;font-weight:700>,</span>
</span></span><span style=display:flex><span>    <span style=color:#4e9a06>&#34;127.0.0.1&#34;</span><span style=color:#000;font-weight:700>,</span>
</span></span><span style=display:flex><span>    <span style=color:#4e9a06>&#34;localhost&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#000;font-weight:700>],</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span><span style=color:#000;font-weight:700>{</span>
</span></span><span style=display:flex><span>  <span style=color:#204a87;font-weight:700>&#34;CN&#34;</span><span style=color:#000;font-weight:700>:</span> <span style=color:#4e9a06>&#34;etcd.local&#34;</span><span style=color:#000;font-weight:700>,</span>
</span></span><span style=display:flex><span>  <span style=color:#204a87;font-weight:700>&#34;hosts&#34;</span><span style=color:#000;font-weight:700>:</span> <span style=color:#000;font-weight:700>[</span>
</span></span><span style=display:flex><span>    <span style=color:#4e9a06>&#34;m2.etcd.local&#34;</span><span style=color:#000;font-weight:700>,</span>
</span></span><span style=display:flex><span>    <span style=color:#4e9a06>&#34;127.0.0.1&#34;</span><span style=color:#000;font-weight:700>,</span>
</span></span><span style=display:flex><span>    <span style=color:#4e9a06>&#34;localhost&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#000;font-weight:700>],</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span><span style=color:#000;font-weight:700>{</span>
</span></span><span style=display:flex><span>  <span style=color:#204a87;font-weight:700>&#34;CN&#34;</span><span style=color:#000;font-weight:700>:</span> <span style=color:#4e9a06>&#34;etcd.local&#34;</span><span style=color:#000;font-weight:700>,</span>
</span></span><span style=display:flex><span>  <span style=color:#204a87;font-weight:700>&#34;hosts&#34;</span><span style=color:#000;font-weight:700>:</span> <span style=color:#000;font-weight:700>[</span>
</span></span><span style=display:flex><span>    <span style=color:#4e9a06>&#34;m3.etcd.local&#34;</span><span style=color:#000;font-weight:700>,</span>
</span></span><span style=display:flex><span>    <span style=color:#4e9a06>&#34;127.0.0.1&#34;</span><span style=color:#000;font-weight:700>,</span>
</span></span><span style=display:flex><span>    <span style=color:#4e9a06>&#34;localhost&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#000;font-weight:700>],</span>
</span></span></code></pre></div><p>Then only peers with matching common names will be authenticated if <code>--peer-cert-allowed-cn etcd.local</code> is given. And nodes with different CNs in CSRs or different <code>--peer-cert-allowed-cn</code> will be rejected:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ etcd --peer-cert-allowed-cn m1.etcd.local
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>I <span style=color:#000;font-weight:700>|</span> embed: rejected connection from <span style=color:#4e9a06>&#34;127.0.0.1:48044&#34;</span> <span style=color:#ce5c00;font-weight:700>(</span>error <span style=color:#4e9a06>&#34;CommonName authentication failed&#34;</span>, ServerName <span style=color:#4e9a06>&#34;m1.etcd.local&#34;</span><span style=color:#ce5c00;font-weight:700>)</span>
</span></span><span style=display:flex><span>I <span style=color:#000;font-weight:700>|</span> embed: rejected connection from <span style=color:#4e9a06>&#34;127.0.0.1:55702&#34;</span> <span style=color:#ce5c00;font-weight:700>(</span>error <span style=color:#4e9a06>&#34;remote error: tls: bad certificate&#34;</span>, ServerName <span style=color:#4e9a06>&#34;m3.etcd.local&#34;</span><span style=color:#ce5c00;font-weight:700>)</span>
</span></span></code></pre></div><p>Each process should be started with:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>etcd --peer-cert-allowed-cn etcd.local
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>I <span style=color:#000;font-weight:700>|</span> pkg/netutil: resolving m3.etcd.local:32380 to 127.0.0.1:32380
</span></span><span style=display:flex><span>I <span style=color:#000;font-weight:700>|</span> pkg/netutil: resolving m2.etcd.local:22380 to 127.0.0.1:22380
</span></span><span style=display:flex><span>I <span style=color:#000;font-weight:700>|</span> pkg/netutil: resolving m1.etcd.local:2380 to 127.0.0.1:2380
</span></span><span style=display:flex><span>I <span style=color:#000;font-weight:700>|</span> etcdserver: published <span style=color:#ce5c00;font-weight:700>{</span>Name:m3 ClientURLs:<span style=color:#ce5c00;font-weight:700>[</span>https://m3.etcd.local:32379<span style=color:#ce5c00;font-weight:700>]}</span> to cluster 9db03f09b20de32b
</span></span><span style=display:flex><span>I <span style=color:#000;font-weight:700>|</span> embed: ready to serve client requests
</span></span><span style=display:flex><span>I <span style=color:#000;font-weight:700>|</span> etcdserver: published <span style=color:#ce5c00;font-weight:700>{</span>Name:m1 ClientURLs:<span style=color:#ce5c00;font-weight:700>[</span>https://m1.etcd.local:2379<span style=color:#ce5c00;font-weight:700>]}</span> to cluster 9db03f09b20de32b
</span></span><span style=display:flex><span>I <span style=color:#000;font-weight:700>|</span> embed: ready to serve client requests
</span></span><span style=display:flex><span>I <span style=color:#000;font-weight:700>|</span> etcdserver: published <span style=color:#ce5c00;font-weight:700>{</span>Name:m2 ClientURLs:<span style=color:#ce5c00;font-weight:700>[</span>https://m2.etcd.local:22379<span style=color:#ce5c00;font-weight:700>]}</span> to cluster 9db03f09b20de32b
</span></span><span style=display:flex><span>I <span style=color:#000;font-weight:700>|</span> embed: ready to serve client requests
</span></span><span style=display:flex><span>I <span style=color:#000;font-weight:700>|</span> embed: serving client requests on 127.0.0.1:32379
</span></span><span style=display:flex><span>I <span style=color:#000;font-weight:700>|</span> embed: serving client requests on 127.0.0.1:22379
</span></span><span style=display:flex><span>I <span style=color:#000;font-weight:700>|</span> embed: serving client requests on 127.0.0.1:2379
</span></span></code></pre></div><p><a href=https://github.com/etcd-io/etcd/blob/master/CHANGELOG-3.2.md target=_blank rel=noopener>v3.2.19</a> and <a href=https://github.com/etcd-io/etcd/blob/master/CHANGELOG-3.3.md target=_blank rel=noopener>v3.3.4</a> fixes TLS reload when <a href=https://github.com/etcd-io/etcd/issues/9541 target=_blank rel=noopener>certificate SAN field only includes IP addresses but no domain names</a>. For example, a member is set up with CSRs (with <code>cfssl</code>) as below:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span><span style=color:#000;font-weight:700>{</span>
</span></span><span style=display:flex><span>  <span style=color:#204a87;font-weight:700>&#34;CN&#34;</span><span style=color:#000;font-weight:700>:</span> <span style=color:#4e9a06>&#34;etcd.local&#34;</span><span style=color:#000;font-weight:700>,</span>
</span></span><span style=display:flex><span>  <span style=color:#204a87;font-weight:700>&#34;hosts&#34;</span><span style=color:#000;font-weight:700>:</span> <span style=color:#000;font-weight:700>[</span>
</span></span><span style=display:flex><span>    <span style=color:#4e9a06>&#34;127.0.0.1&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#000;font-weight:700>],</span>
</span></span></code></pre></div><p>In Go, server calls <code>(*tls.Config).GetCertificate</code> for TLS reload if and only if server&rsquo;s <code>(*tls.Config).Certificates</code> field is not empty, or <code>(*tls.ClientHelloInfo).ServerName</code> is not empty with a valid SNI from the client. Previously, etcd always populates <code>(*tls.Config).Certificates</code> on the initial client TLS handshake, as non-empty. Thus, client was always expected to supply a matching SNI in order to pass the TLS verification and to trigger <code>(*tls.Config).GetCertificate</code> to reload TLS assets.</p><p>However, a certificate whose SAN field does <a href=https://github.com/etcd-io/etcd/issues/9541 target=_blank rel=noopener>not include any domain names but only IP addresses</a> would request <code>*tls.ClientHelloInfo</code> with an empty <code>ServerName</code> field, thus failing to trigger the TLS reload on initial TLS handshake; this becomes a problem when expired certificates need to be replaced online.</p><p>Now, <code>(*tls.Config).Certificates</code> is created empty on initial TLS client handshake, first to trigger <code>(*tls.Config).GetCertificate</code>, and then to populate rest of the certificates on every new TLS connection, even when client SNI is empty (e.g. cert only includes IPs).</p><h2 id=notes-for-host-whitelist>Notes for Host Whitelist</h2><p><code>etcd --host-whitelist</code> flag specifies acceptable hostnames from HTTP client requests. Client origin policy protects against <a href=https://en.wikipedia.org/wiki/DNS_rebinding target=_blank rel=noopener>&ldquo;DNS Rebinding&rdquo;</a> attacks to insecure etcd servers. That is, any website can simply create an authorized DNS name, and direct DNS to <code>"localhost"</code> (or any other address). Then, all HTTP endpoints of etcd server listening on <code>"localhost"</code> becomes accessible, thus vulnerable to DNS rebinding attacks. See <a href="https://bugs.chromium.org/p/project-zero/issues/detail?id=1447#c2" target=_blank rel=noopener>CVE-2018-5702</a> for more detail.</p><p>Client origin policy works as follows:</p><ol><li>If client connection is secure via HTTPS, allow any hostnames.</li><li>If client connection is not secure and <code>"HostWhitelist"</code> is not empty, only allow HTTP requests whose Host field is listed in whitelist.</li></ol><p>Note that the client origin policy is enforced whether authentication is enabled or not, for tighter controls.</p><p>By default, <code>etcd --host-whitelist</code> and <code>embed.Config.HostWhitelist</code> are set <em>empty</em> to allow all hostnames. Note that when specifying hostnames, loopback addresses are not added automatically. To allow loopback interfaces, add them to whitelist manually (e.g. <code>"localhost"</code>, <code>"127.0.0.1"</code>, etc.).</p><h2 id=frequently-asked-questions>Frequently asked questions</h2><h3 id=im-seeing-a-sslv3-alert-handshake-failure-when-using-tls-client-authentication>I&rsquo;m seeing a SSLv3 alert handshake failure when using TLS client authentication?</h3><p>The <code>crypto/tls</code> package of <code>golang</code> checks the key usage of the certificate public key before using it. To use the certificate public key to do client auth, we need to add <code>clientAuth</code> to <code>Extended Key Usage</code> when creating the certificate public key.</p><p>Here is how to do it:</p><p>Add the following section to openssl.cnf:</p><pre tabindex=0><code>[ ssl_client ]
...
  extendedKeyUsage = clientAuth
...
</code></pre><p>When creating the cert be sure to reference it in the <code>-extensions</code> flag:</p><pre tabindex=0><code>$ openssl ca -config openssl.cnf -policy policy_anything -extensions ssl_client -out certs/machine.crt -infiles machine.csr
</code></pre><p>The <a href=https://pkg.go.dev/crypto/x509#Certificate.Verify target=_blank rel=noopener><code>Verify</code></a> function in the <code>crypto/x509</code> logic implements a common, but non-standard extension - it requires that CA & intermediate certificates either define no extended key usage, or a superset of those on the end-entity certificates. If certificates in your chain define any extended key usages, they must also include <code>serverAuth</code> and/or <code>clientAuth</code>.</p><p>Otherwise, you may see an error like <code>unsuitable certificate purpose</code> (OpenSSL) or <code>certificate specifies an incompatible key usage</code> (Go).</p><h3 id=with-peer-certificate-authentication-i-receive-certificate-is-valid-for-127001-not-my_ip>With peer certificate authentication I receive &ldquo;certificate is valid for 127.0.0.1, not $MY_IP&rdquo;</h3><p>Make sure to sign the certificates with a Subject Name the member&rsquo;s public IP address. The <code>etcd-ca</code> tool for example provides an <code>--ip=</code> option for its <code>new-cert</code> command.</p><p>The certificate needs to be signed for the member&rsquo;s FQDN in its Subject Name, use Subject Alternative Names (short IP SANs) to add the IP address. The <code>etcd-ca</code> tool provides <code>--domain=</code> option for its <code>new-cert</code> command, and openssl can make <a href=http://wiki.cacert.org/FAQ/subjectAltName target=_blank rel=noopener>it</a> too.</p><h3 id=does-etcd-encrypt-data-stored-on-disk-drives>Does etcd encrypt data stored on disk drives?</h3><p>No. etcd doesn&rsquo;t encrypt key/value data stored on disk drives. If a user need to encrypt data stored on etcd, there are some options:</p><ul><li>Let client applications encrypt and decrypt the data</li><li>Use a feature of underlying storage systems for encrypting stored data like <a href=https://en.wikipedia.org/wiki/Dm-crypt target=_blank rel=noopener>dm-crypt</a></li></ul><h3 id=im-seeing-a-log-warning-that-directory-x-exist-without-recommended-permission--rwx>I’m seeing a log warning that &ldquo;directory X exist without recommended permission -rwx&mdash;&mdash;&rdquo;</h3><p>When etcd create certain new directories it sets file permission to 700 to prevent unprivileged access as possible. However, if user has already created a directory with own preference, etcd uses the existing directory and logs a warning message if the permission is different than 700.</p><div class=d-print-none><h2 class=feedback--title>Feedback</h2><p class=feedback--question>Was this page helpful?</p><button class="btn btn-primary mb-4 feedback--answer feedback--answer-yes">Yes</button>
<button class="btn btn-primary mb-4 feedback--answer feedback--answer-no">No</button><p class="feedback--response feedback--response-yes">Glad to hear it! Please <a href=https://github.com/etcd-io/website/issues/new>tell us how we can improve</a>.</p><p class="feedback--response feedback--response-no">Sorry to hear that. Please <a href=https://github.com/etcd-io/website/issues/new>tell us how we can improve</a>.</p></div><br><div class=td-page-meta__lastmod>Last modified October 25, 2023: <a href=https://github.com/etcd-io/website/commit/2daba9146a9aa9c8063c383b12e06fa5e61c9bc5>Describe requirements on intermediate certificates (2daba91)</a></div></div></main></div></div></div></body></html>