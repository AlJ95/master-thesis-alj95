<!doctype html><html itemscope itemtype=http://schema.org/WebPage lang=en class=no-js><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Monitoring etcd | etcd</title>
<meta name=description content="Monitoring etcd for system health & cluster debugging"><meta property="og:url" content="https://etcd.io/docs/v3.5/op-guide/monitoring/"><meta property="og:site_name" content="etcd"><meta property="og:title" content="Monitoring etcd"><meta property="og:description" content="Monitoring etcd for system health & cluster debugging"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="docs"><meta property="article:modified_time" content="2024-01-02T09:36:15-08:00"><meta itemprop=name content="Monitoring etcd"><meta itemprop=description content="Monitoring etcd for system health & cluster debugging"><meta itemprop=dateModified content="2024-01-02T09:36:15-08:00"><meta itemprop=wordCount content="870"><meta name=twitter:card content="summary"><meta name=twitter:title content="Monitoring etcd"><meta name=twitter:description content="Monitoring etcd for system health & cluster debugging"></head><body class=td-page><div class="container-fluid td-outer"><div class=td-main><div class="row flex-xl-nowrap"><main class="col-12 col-md-9 col-xl-8 ps-md-5" role=main><div class=td-content><h1>Monitoring etcd</h1><div class=lead>Monitoring etcd for system health & cluster debugging</div><p>Each etcd server provides local monitoring information on its client port through http endpoints. The monitoring data is useful for both system health checking and cluster debugging.</p><h2 id=debug-endpoint>Debug endpoint</h2><p>If <code>--log-level=debug</code> is set, the etcd server exports debugging information on its client port under the <code>/debug</code> path. Take care when setting <code>--log-level=debug</code>, since there will be degraded performance and verbose logging.</p><p>The <code>/debug/pprof</code> endpoint is the standard go runtime profiling endpoint. This can be used to profile CPU, heap, mutex, and goroutine utilization. For example, here <code>go tool pprof</code> gets the top 10 functions where etcd spends its time:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>$ go tool pprof http://localhost:2379/debug/pprof/profile
</span></span><span style=display:flex><span>Fetching profile from http://localhost:2379/debug/pprof/profile
</span></span><span style=display:flex><span>Please wait... <span style=color:#ce5c00;font-weight:700>(</span>30s<span style=color:#ce5c00;font-weight:700>)</span>
</span></span><span style=display:flex><span>Saved profile in /home/etcd/pprof/pprof.etcd.localhost:2379.samples.cpu.001.pb.gz
</span></span><span style=display:flex><span>Entering interactive mode <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#204a87>type</span> <span style=color:#4e9a06>&#34;help&#34;</span> <span style=color:#204a87;font-weight:700>for</span> commands<span style=color:#ce5c00;font-weight:700>)</span>
</span></span><span style=display:flex><span><span style=color:#ce5c00;font-weight:700>(</span>pprof<span style=color:#ce5c00;font-weight:700>)</span> top10
</span></span><span style=display:flex><span>310ms of 480ms total <span style=color:#ce5c00;font-weight:700>(</span>64.58%<span style=color:#ce5c00;font-weight:700>)</span>
</span></span><span style=display:flex><span>Showing top <span style=color:#0000cf;font-weight:700>10</span> nodes out of <span style=color:#0000cf;font-weight:700>157</span> <span style=color:#ce5c00;font-weight:700>(</span>cum &gt;<span style=color:#ce5c00;font-weight:700>=</span> 10ms<span style=color:#ce5c00;font-weight:700>)</span>
</span></span><span style=display:flex><span>    flat  flat%   sum%        cum   cum%
</span></span><span style=display:flex><span>   130ms 27.08% 27.08%      130ms 27.08%  runtime.futex
</span></span><span style=display:flex><span>    70ms 14.58% 41.67%       70ms 14.58%  syscall.Syscall
</span></span><span style=display:flex><span>    20ms  4.17% 45.83%       20ms  4.17%  github.com/coreos/etcd/vendor/golang.org/x/net/http2/hpack.huffmanDecode
</span></span><span style=display:flex><span>    20ms  4.17% 50.00%       30ms  6.25%  runtime.pcvalue
</span></span><span style=display:flex><span>    20ms  4.17% 54.17%       50ms 10.42%  runtime.schedule
</span></span><span style=display:flex><span>    10ms  2.08% 56.25%       10ms  2.08%  github.com/coreos/etcd/vendor/github.com/coreos/etcd/etcdserver.<span style=color:#ce5c00;font-weight:700>(</span>*EtcdServer<span style=color:#ce5c00;font-weight:700>)</span>.AuthInfoFromCtx
</span></span><span style=display:flex><span>    10ms  2.08% 58.33%       10ms  2.08%  github.com/coreos/etcd/vendor/github.com/coreos/etcd/etcdserver.<span style=color:#ce5c00;font-weight:700>(</span>*EtcdServer<span style=color:#ce5c00;font-weight:700>)</span>.Lead
</span></span><span style=display:flex><span>    10ms  2.08% 60.42%       10ms  2.08%  github.com/coreos/etcd/vendor/github.com/coreos/etcd/pkg/wait.<span style=color:#ce5c00;font-weight:700>(</span>*timeList<span style=color:#ce5c00;font-weight:700>)</span>.Trigger
</span></span><span style=display:flex><span>    10ms  2.08% 62.50%       10ms  2.08%  github.com/coreos/etcd/vendor/github.com/prometheus/client_golang/prometheus.<span style=color:#ce5c00;font-weight:700>(</span>*MetricVec<span style=color:#ce5c00;font-weight:700>)</span>.hashLabelValues
</span></span><span style=display:flex><span>    10ms  2.08% 64.58%       10ms  2.08%  github.com/coreos/etcd/vendor/golang.org/x/net/http2.<span style=color:#ce5c00;font-weight:700>(</span>*Framer<span style=color:#ce5c00;font-weight:700>)</span>.WriteHeaders
</span></span></code></pre></div><p>The <code>/debug/requests</code> endpoint gives gRPC traces and performance statistics through a web browser. For example, here is a <code>Range</code> request for the key <code>abc</code>:</p><pre tabindex=0><code>When	Elapsed (s)
2017/08/18 17:34:51.999317 	0.000244 	/etcdserverpb.KV/Range
17:34:51.999382 	 .    65 	... RPC: from 127.0.0.1:47204 deadline:4.999377747s
17:34:51.999395 	 .    13 	... recv: key:&#34;abc&#34;
17:34:51.999499 	 .   104 	... OK
17:34:51.999535 	 .    36 	... sent: header:&lt;cluster_id:14841639068965178418 member_id:10276657743932975437 revision:15 raft_term:17 &gt; kvs:&lt;key:&#34;abc&#34; create_revision:6 mod_revision:14 version:9 value:&#34;asda&#34; &gt; count:1
</code></pre><h2 id=metrics-endpoint>Metrics endpoint</h2><p>Each etcd server exports metrics under the <code>/metrics</code> path on its client port and optionally on locations given by <code>--listen-metrics-urls</code>.</p><p>The metrics can be fetched with <code>curl</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>$ curl -L http://localhost:2379/metrics <span style=color:#000;font-weight:700>|</span> grep -v debugging <span style=color:#8f5902;font-style:italic># ignore unstable debugging metrics</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic># HELP etcd_disk_backend_commit_duration_seconds The latency distributions of commit called by backend.</span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic># TYPE etcd_disk_backend_commit_duration_seconds histogram</span>
</span></span><span style=display:flex><span>etcd_disk_backend_commit_duration_seconds_bucket<span style=color:#ce5c00;font-weight:700>{</span><span style=color:#000>le</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#4e9a06>&#34;0.002&#34;</span><span style=color:#ce5c00;font-weight:700>}</span> <span style=color:#0000cf;font-weight:700>72756</span>
</span></span><span style=display:flex><span>etcd_disk_backend_commit_duration_seconds_bucket<span style=color:#ce5c00;font-weight:700>{</span><span style=color:#000>le</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#4e9a06>&#34;0.004&#34;</span><span style=color:#ce5c00;font-weight:700>}</span> <span style=color:#0000cf;font-weight:700>401587</span>
</span></span><span style=display:flex><span>etcd_disk_backend_commit_duration_seconds_bucket<span style=color:#ce5c00;font-weight:700>{</span><span style=color:#000>le</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#4e9a06>&#34;0.008&#34;</span><span style=color:#ce5c00;font-weight:700>}</span> <span style=color:#0000cf;font-weight:700>405979</span>
</span></span><span style=display:flex><span>etcd_disk_backend_commit_duration_seconds_bucket<span style=color:#ce5c00;font-weight:700>{</span><span style=color:#000>le</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#4e9a06>&#34;0.016&#34;</span><span style=color:#ce5c00;font-weight:700>}</span> <span style=color:#0000cf;font-weight:700>406464</span>
</span></span><span style=display:flex><span>...
</span></span></code></pre></div><h2 id=health-check>Health Check</h2><p>Since v3.3.0, in addition to responding to the <code>/metrics</code> endpoint, any locations specified by <code>--listen-metrics-urls</code> will also respond to the <code>/health</code> endpoint. This can be useful if the standard endpoint is configured with mutual (client) TLS authentication, but a load balancer or monitoring service still needs access to the health check.</p><p>Since v3.5.12, two new endpoints <code>/livez</code> and <code>/readyz</code> are added.</p><ul><li>the <code>/livez</code> endpoint reflects whether the process is alive or if it needs a restart.</li><li>the <code>/readyz</code> endpoint reflects whether the process is ready to serve traffic.</li></ul><p>Design details of the endpoints are documented in the <a href=https://github.com/kubernetes/enhancements/tree/master/keps/sig-etcd/4331-livez-readyz target=_blank rel=noopener>KEP</a>.</p><p>Each endpoint includes several individual health checks, and you can use the <code>verbose</code> parameter to print out the details of the checks and their status, for example</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>curl -k http://localhost:2379/readyz?verbose
</span></span></code></pre></div><p>and you would see the response similar to</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>[+]data_corruption ok
</span></span><span style=display:flex><span>[+]serializable_read ok
</span></span><span style=display:flex><span>[+]linearizable_read ok
</span></span><span style=display:flex><span>ok
</span></span></code></pre></div><p>The http API also supports to exclude specific checks, for example</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>curl -k http://localhost:2379/readyz?exclude<span style=color:#ce5c00;font-weight:700>=</span>data_corruption
</span></span></code></pre></div><h2 id=prometheus>Prometheus</h2><p>Running a <a href=https://prometheus.io/ target=_blank rel=noopener>Prometheus</a> monitoring service is the easiest way to ingest and record etcd&rsquo;s metrics.</p><p>First, install Prometheus:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span><span style=color:#000>PROMETHEUS_VERSION</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#4e9a06>&#34;2.0.0&#34;</span>
</span></span><span style=display:flex><span>wget https://github.com/prometheus/prometheus/releases/download/v<span style=color:#000>$PROMETHEUS_VERSION</span>/prometheus-<span style=color:#000>$PROMETHEUS_VERSION</span>.linux-amd64.tar.gz -O /tmp/prometheus-<span style=color:#000>$PROMETHEUS_VERSION</span>.linux-amd64.tar.gz
</span></span><span style=display:flex><span>tar -xvzf /tmp/prometheus-<span style=color:#000>$PROMETHEUS_VERSION</span>.linux-amd64.tar.gz --directory /tmp/ --strip-components<span style=color:#ce5c00;font-weight:700>=</span><span style=color:#0000cf;font-weight:700>1</span>
</span></span><span style=display:flex><span>/tmp/prometheus -version
</span></span></code></pre></div><p>Set Prometheus&rsquo;s scraper to target the etcd cluster endpoints:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>cat &gt; /tmp/test-etcd.yaml <span style=color:#4e9a06>&lt;&lt;EOF
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>global:
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>  scrape_interval: 10s
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>scrape_configs:
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>  - job_name: test-etcd
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>    static_configs:
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>    - targets: [&#39;10.240.0.32:2379&#39;,&#39;10.240.0.33:2379&#39;,&#39;10.240.0.34:2379&#39;]
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>EOF</span>
</span></span><span style=display:flex><span>cat /tmp/test-etcd.yaml
</span></span></code></pre></div><p>Set up the Prometheus handler:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>nohup /tmp/prometheus <span style=color:#4e9a06>\
</span></span></span><span style=display:flex><span><span style=color:#4e9a06></span>    -config.file /tmp/test-etcd.yaml <span style=color:#4e9a06>\
</span></span></span><span style=display:flex><span><span style=color:#4e9a06></span>    -web.listen-address <span style=color:#4e9a06>&#34;:9090&#34;</span> <span style=color:#4e9a06>\
</span></span></span><span style=display:flex><span><span style=color:#4e9a06></span>    -storage.local.path <span style=color:#4e9a06>&#34;test-etcd.data&#34;</span> &gt;&gt; /tmp/test-etcd.log  2&gt;<span style=color:#000;font-weight:700>&amp;</span><span style=color:#0000cf;font-weight:700>1</span> <span style=color:#000;font-weight:700>&amp;</span>
</span></span></code></pre></div><p>Now Prometheus will scrape etcd metrics every 10 seconds.</p><h3 id=alerting>Alerting</h3><p>There is a set of <a href=https://github.com/etcd-io/etcd/tree/master/contrib/mixin target=_blank rel=noopener>default alerts</a> for etcd v3 clusters for Prometheus.</p><div class="alert alert-info" role=alert><h4 class=alert-heading>Note</h4>Note that <code>job</code> labels may need to be adjusted to fit a particular need. The rules were written to apply to a single cluster so it is recommended to choose labels unique to a cluster.</div><h3 id=grafana>Grafana</h3><p><a href=http://grafana.org/ target=_blank rel=noopener>Grafana</a> has built-in Prometheus support; just add a Prometheus data source:</p><pre tabindex=0><code>Name:   test-etcd
Type:   Prometheus
Url:    http://localhost:9090
Access: proxy
</code></pre><p>Then import the default <a href=../grafana.json>etcd dashboard template</a> and customize. For instance, if Prometheus data source name is <code>my-etcd</code>, the <code>datasource</code> field values in JSON also need to be <code>my-etcd</code>.</p><p>Sample dashboard:</p><p></p><h2 id=distributed-tracing>Distributed tracing</h2><p>In v3.5 etcd has added support for distributed tracing using <a href=https://github.com/open-telemetry target=_blank rel=noopener>OpenTelemetry</a>.</p><div class="alert alert-info" role=alert><h4 class=alert-heading>Note</h4>This feature is still experimental and can change at any time.</div><p>To enable this experimental feature, pass the <code>--experimental-enable-distributed-tracing=true</code> to the etcd server, along with the <code>--experimental-distributed-tracing-sampling-rate=&lt;number></code> flag to choose how many samples to collect per million spans, the default sampling rate is <code>0</code>.</p><p>Configure the distributed tracing by starting etcd server with the following optional flags:</p><ul><li><p><code>--experimental-distributed-tracing-address</code> - (Optional) - &ldquo;localhost:4317&rdquo; - Address of the tracing collector.</p></li><li><p><code>--experimental-distributed-tracing-service-name</code> - (Optional) - &ldquo;etcd&rdquo; - Distributed tracing service name, must be same across all etcd instances.</p></li><li><p><code>--experimental-distributed-tracing-instance-id</code> - (Optional) - Instance ID, while optional it&rsquo;s strongly recommended to set, must be unique per etcd instance.</p></li></ul><p>Before enabling the distributed tracing, make sure to have the OpenTelemetry endpoint, if that address differs to the default one, override with the <code>--experimental-distributed-tracing-address</code> flag. Due to OpenTelemetry having different ways of running, refer to the <a href=https://opentelemetry.io/docs/collector/getting-started/ target=_blank rel=noopener>collector documentation</a> to learn more.</p><div class="alert alert-info" role=alert><h4 class=alert-heading>Note</h4>There is a resource overhead, as with any observability signal, according to our initial measurements that overhead could be between 2% - 4% CPU overhead.</div><div class=d-print-none><h2 class=feedback--title>Feedback</h2><p class=feedback--question>Was this page helpful?</p><button class="btn btn-primary mb-4 feedback--answer feedback--answer-yes">Yes</button>
<button class="btn btn-primary mb-4 feedback--answer feedback--answer-no">No</button><p class="feedback--response feedback--response-yes">Glad to hear it! Please <a href=https://github.com/etcd-io/website/issues/new>tell us how we can improve</a>.</p><p class="feedback--response feedback--response-no">Sorry to hear that. Please <a href=https://github.com/etcd-io/website/issues/new>tell us how we can improve</a>.</p></div><br><div class=td-page-meta__lastmod>Last modified January 2, 2024: <a href=https://github.com/etcd-io/website/commit/e55accd3cad594e3485d68a7f94a3576bb1948b5>Document the new livez/readyz endpoints. (e55accd)</a></div></div></main></div></div></div></body></html>