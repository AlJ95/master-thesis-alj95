[{"label":"0","content":"void CVE_2015_4003_PATCHED_oz_usb_handle_ep_data(struct oz_usb_ctx *usb_ctx,\n\tstruct oz_usb_hdr *usb_hdr, int len)\n{\n\tstruct oz_data *data_hdr = (struct oz_data *)usb_hdr;\n\tswitch (data_hdr->format) {\n\tcase OZ_DATA_F_MULTIPLE_FIXED: {\n\t\t\tstruct oz_multiple_fixed *body =\n\t\t\t\t(struct oz_multiple_fixed *)data_hdr;\n\t\t\tu8 *data = body->data;\n\t\t\tint n;\n\t\t\tif (!body->unit_size)\n\t\t\t\tbreak;\n\t\t\tn = (len - sizeof(struct oz_multiple_fixed)+1)\n\t\t\t\t\/ body->unit_size;\n\t\t\twhile (n--) {\n\t\t\t\toz_hcd_data_ind(usb_ctx->hport, body->endpoint,\n\t\t\t\t\tdata, body->unit_size);\n\t\t\t\tdata += body->unit_size;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase OZ_DATA_F_ISOC_FIXED: {\n\t\t\tstruct oz_isoc_fixed *body =\n\t\t\t\t(struct oz_isoc_fixed *)data_hdr;\n\t\t\tint data_len = len-sizeof(struct oz_isoc_fixed)+1;\n\t\t\tint unit_size = body->unit_size;\n\t\t\tu8 *data = body->data;\n\t\t\tint count;\n\t\t\tint i;\n\t\t\tif (!unit_size)\n\t\t\t\tbreak;\n\t\t\tcount = data_len\/unit_size;\n\t\t\tfor (i = 0; i < count; i++) {\n\t\t\t\toz_hcd_data_ind(usb_ctx->hport,\n\t\t\t\t\tbody->endpoint, data, unit_size);\n\t\t\t\tdata += unit_size;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\n}\n"},{"label":"0","content":"static guint16\nCVE_2015_4652_PATCHED_de_bcd_num(tvbuff_t *tvb, proto_tree *tree, packet_info *pinfo, guint32 offset, guint len, int header_field, gboolean *address_extracted)\n{\n\tguint8     *poctets;\n    guint8      extension;\n    guint32     curr_offset, num_string_len;\n\tproto_item *item;\n    const char *digit_str;\n\n\t*address_extracted = FALSE;\n\tcurr_offset = offset;\n\n\textension = tvb_get_guint8(tvb, curr_offset) & 0x80;\n\tproto_tree_add_item(tree, hf_gsm_a_extension, tvb, curr_offset, 1, ENC_BIG_ENDIAN);\n\tproto_tree_add_item(tree, hf_gsm_a_dtap_type_of_number, tvb, curr_offset, 1, ENC_BIG_ENDIAN);\n\tproto_tree_add_item(tree, hf_gsm_a_dtap_numbering_plan_id, tvb, curr_offset, 1, ENC_BIG_ENDIAN);\n\tcurr_offset++;\n\n\tif (!extension)\n\t{\n\t\tproto_tree_add_item(tree, hf_gsm_a_extension, tvb, curr_offset, 1, ENC_BIG_ENDIAN);\n\t\tproto_tree_add_item(tree, hf_gsm_a_dtap_present_ind, tvb, curr_offset, 1, ENC_BIG_ENDIAN);\n\t\tproto_tree_add_bits_item(tree, hf_gsm_a_spare_bits, tvb, (curr_offset<<3)+3, 3, ENC_BIG_ENDIAN);\n\t\tproto_tree_add_item(tree, hf_gsm_a_dtap_screening_ind, tvb, curr_offset, 1, ENC_BIG_ENDIAN);\n\t\tcurr_offset++;\n\t}\n\n\tNO_MORE_DATA_CHECK(len);\n\n\tnum_string_len = len - (curr_offset - offset);\n\tpoctets = (guint8 *)tvb_memdup(wmem_packet_scope(), tvb, curr_offset, num_string_len);\n\n\t*address_extracted = TRUE;\n\tmy_dgt_tbcd_unpack(a_bigbuf, poctets, num_string_len,\n\t\t&Dgt_mbcd);\n\n    digit_str = tvb_bcd_dig_to_wmem_packet_str(tvb, curr_offset, num_string_len, NULL, FALSE);\n    item = proto_tree_add_string(tree, header_field, tvb, curr_offset, num_string_len, digit_str);\n\titem = proto_tree_add_string_format(tree, header_field,\n\t\ttvb, curr_offset, num_string_len,\n\t\ta_bigbuf,\n\t\t\"BCD Digits: %s\",\n\t\ta_bigbuf);\n\n    \/* Check for overdicadic digits, we used the standard digit map from tvbuff.c\n               *  0   1   2   3   4   5   6   7   8   9   a   b   c   d   e  f\n               * '0','1','2','3','4','5','6','7','8','9','?','?','?','?','?','?'\n        *\n        *\/\n    if(strchr(digit_str,'?')){\n\t\texpert_add_info(pinfo, item, &ei_gsm_a_dtap_end_mark_unexpected);\n    }\n\n\treturn(len);\n}\n"},{"label":"0","content":"static gint\nCVE_2015_6249_PATCHED_dissect_wccp2r1_address_table_info(tvbuff_t *tvb, int offset, int length,\n                                   packet_info *pinfo, proto_tree *info_tree)\n{\n  guint16 address_length;\n  guint32 i;\n  gint16 family;\n  guint16 table_length;\n  proto_tree *element_tree;\n  proto_item *tf;\n\n  if (info_tree)\n    tf = proto_tree_get_parent(info_tree);\n\n  if (length < 2*4)\n    return length - 2*4;\n\n  family = tvb_get_ntohs(tvb, offset);\n  proto_tree_add_item(info_tree, hf_address_table_family, tvb, offset, 2, ENC_BIG_ENDIAN);\n  EAT_AND_CHECK(2,2);\n\n  address_length = tvb_get_ntohs(tvb, offset);\n  proto_tree_add_item(info_tree, hf_address_table_address_length, tvb, offset, 2, ENC_BIG_ENDIAN);\n  EAT_AND_CHECK(2,2);\n\n  table_length =  tvb_get_ntohl(tvb, offset);\n  tf = proto_tree_add_item(info_tree, hf_address_table_length, tvb, offset, 4, ENC_BIG_ENDIAN);\n  element_tree = proto_item_add_subtree(tf, ett_table_element);\n  EAT(4);\n\n  if (wccp_wccp_address_table.in_use == FALSE) {\n    wccp_wccp_address_table.family = family;\n    wccp_wccp_address_table.table_length =  table_length;\n\n    \/* check if the length is valid and allocate the tables if needed *\/\n    switch (wccp_wccp_address_table.family) {\n    case 1:\n      if (wccp_wccp_address_table.table_ipv4 == NULL)\n        wccp_wccp_address_table.table_ipv4 = (guint32 *)\n          wmem_alloc0(pinfo->pool, wccp_wccp_address_table.table_length * 4);\n      if (address_length != 4) {\n        expert_add_info_format(pinfo, tf, &ei_wccp_length_bad,\n                               \"The Address length must be 4, but I found %d for IPv4 addresses. Correcting this.\",\n                               address_length);\n        address_length = 4;\n      }\n      break;\n    case 2:\n      if (wccp_wccp_address_table.table_ipv6 == NULL)\n        wccp_wccp_address_table.table_ipv6 = (struct e_in6_addr *)\n          wmem_alloc0(pinfo->pool, wccp_wccp_address_table.table_length * sizeof(struct e_in6_addr));\n      if (address_length != 16) {\n        expert_add_info_format(pinfo, tf, &ei_wccp_length_bad,\n                               \"The Address length must be 16, but I found %d for IPv6 addresses. Correcting this.\",\n                               address_length);\n        address_length = 16;\n      }\n      break;\n    default:\n      expert_add_info_format(pinfo, tf, &ei_wccp_address_table_family_unknown,\n                      \"Unknown address family: %d\", wccp_wccp_address_table.family);\n    };\n  }\n\n  \/* now read the addresses and print\/store them *\/\n\n  for(i=0; i<table_length; i++) {\n    const gchar *addr;\n\n    switch (family) {\n    case 1:\n      \/* IPv4 *\/\n      addr  =  tvb_ip_to_str(tvb, offset);\n      if ((wccp_wccp_address_table.in_use == FALSE) &&\n          (wccp_wccp_address_table.table_ipv4 != NULL) &&\n          ((address_length * i) < wccp_wccp_address_table.table_length))\n        wccp_wccp_address_table.table_ipv4[i] = tvb_get_ntohl(tvb, offset);\n      break;\n    case 2:\n      \/* IPv6 *\/\n      addr = tvb_ip6_to_str(tvb, offset);\n      if ((wccp_wccp_address_table.in_use == FALSE) &&\n          (wccp_wccp_address_table.table_ipv6 != NULL) &&\n          (i < wccp_wccp_address_table.table_length))\n        tvb_get_ipv6(tvb, offset, &(wccp_wccp_address_table.table_ipv6[i]));\n      break;\n    default:\n      addr = wmem_strdup_printf(wmem_packet_scope(), \"unknown family %d\", wccp_wccp_address_table.family);\n    };\n\n    if (element_tree) {\n      proto_item *pi;\n\n      pi = proto_tree_add_string_format_value(element_tree, hf_address_table_element, tvb,\n                                              offset, address_length, addr,\n                                              \"%d: %s\", i+1, addr);\n      if (i > wccp_wccp_address_table.table_length)\n        expert_add_info_format(pinfo, pi, &ei_wccp_length_bad, \"Ran out of space to store address\");\n    }\n    EAT(address_length);\n  }\n\n  wccp_wccp_address_table.in_use = TRUE;\n  return length;\n}\n"},{"label":"1","content":"static int CVE_2005_3356_VULN_mq_attr_ok(struct mq_attr *attr)\n{\n\tif (attr->mq_maxmsg <= 0 || attr->mq_msgsize <= 0)\n\t\treturn 0;\n\tif (capable(CAP_SYS_RESOURCE)) {\n\t\tif (attr->mq_maxmsg > HARD_MSGMAX)\n\t\t\treturn 0;\n\t} else {\n\t\tif (attr->mq_maxmsg > msg_max ||\n\t\t\t\tattr->mq_msgsize > msgsize_max)\n\t\t\treturn 0;\n\t}\n\t\/* check for overflow *\/\n\tif (attr->mq_msgsize > ULONG_MAX\/attr->mq_maxmsg)\n\t\treturn 0;\n\tif ((unsigned long)(attr->mq_maxmsg * attr->mq_msgsize) +\n\t    (attr->mq_maxmsg * sizeof (struct msg_msg *)) <\n\t    (unsigned long)(attr->mq_maxmsg * attr->mq_msgsize))\n\t\treturn 0;\n\treturn 1;\n}\n"}]