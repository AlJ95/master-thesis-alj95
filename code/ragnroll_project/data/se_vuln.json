{"label":{"0_CVE_2015_4003_PATCHED_oz_usb_handle_ep_data":"0","0_CVE_2015_4652_PATCHED_de_bcd_num":"0","0_CVE_2015_6243_PATCHED_dissector_get_default_string_handle":"0","0_CVE_2015_6243_PATCHED_dissector_get_string_handle":"0","0_CVE_2015_6246_PATCHED_dissect_wa_payload":"0","0_CVE_2015_6249_PATCHED_dissect_wccp2r1_address_table_info":"0","0_CVE_2015_6654_PATCHED_xenmem_add_to_physmap_one":"0","1_CVE_2005_0146_VULN_nsTextEditorMouseListener__MouseClick":"1","1_CVE_2005_2492_VULN_rawv6_probe_proto_opt":"1","1_CVE_2005_2617_VULN_syscall32_setup_pages":"1","1_CVE_2005_2800_VULN_dev_seq_next":"1","1_CVE_2005_2800_VULN_dev_seq_start":"1","1_CVE_2005_3181_VULN_open_namei":"1","1_CVE_2005_3356_VULN_do_create":"1","1_CVE_2005_3356_VULN_do_open":"1","1_CVE_2005_3356_VULN_mq_attr_ok":"1","1_CVE_2005_3356_VULN_sys_mq_open":"1"},"content":{"0_CVE_2015_4003_PATCHED_oz_usb_handle_ep_data":"void CVE_2015_4003_PATCHED_oz_usb_handle_ep_data(struct oz_usb_ctx *usb_ctx,\n\tstruct oz_usb_hdr *usb_hdr, int len)\n{\n\tstruct oz_data *data_hdr = (struct oz_data *)usb_hdr;\n\tswitch (data_hdr->format) {\n\tcase OZ_DATA_F_MULTIPLE_FIXED: {\n\t\t\tstruct oz_multiple_fixed *body =\n\t\t\t\t(struct oz_multiple_fixed *)data_hdr;\n\t\t\tu8 *data = body->data;\n\t\t\tint n;\n\t\t\tif (!body->unit_size)\n\t\t\t\tbreak;\n\t\t\tn = (len - sizeof(struct oz_multiple_fixed)+1)\n\t\t\t\t\/ body->unit_size;\n\t\t\twhile (n--) {\n\t\t\t\toz_hcd_data_ind(usb_ctx->hport, body->endpoint,\n\t\t\t\t\tdata, body->unit_size);\n\t\t\t\tdata += body->unit_size;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase OZ_DATA_F_ISOC_FIXED: {\n\t\t\tstruct oz_isoc_fixed *body =\n\t\t\t\t(struct oz_isoc_fixed *)data_hdr;\n\t\t\tint data_len = len-sizeof(struct oz_isoc_fixed)+1;\n\t\t\tint unit_size = body->unit_size;\n\t\t\tu8 *data = body->data;\n\t\t\tint count;\n\t\t\tint i;\n\t\t\tif (!unit_size)\n\t\t\t\tbreak;\n\t\t\tcount = data_len\/unit_size;\n\t\t\tfor (i = 0; i < count; i++) {\n\t\t\t\toz_hcd_data_ind(usb_ctx->hport,\n\t\t\t\t\tbody->endpoint, data, unit_size);\n\t\t\t\tdata += unit_size;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\n}\n","0_CVE_2015_4652_PATCHED_de_bcd_num":"static guint16\nCVE_2015_4652_PATCHED_de_bcd_num(tvbuff_t *tvb, proto_tree *tree, packet_info *pinfo, guint32 offset, guint len, int header_field, gboolean *address_extracted)\n{\n\tguint8     *poctets;\n    guint8      extension;\n    guint32     curr_offset, num_string_len;\n\tproto_item *item;\n    const char *digit_str;\n\n\t*address_extracted = FALSE;\n\tcurr_offset = offset;\n\n\textension = tvb_get_guint8(tvb, curr_offset) & 0x80;\n\tproto_tree_add_item(tree, hf_gsm_a_extension, tvb, curr_offset, 1, ENC_BIG_ENDIAN);\n\tproto_tree_add_item(tree, hf_gsm_a_dtap_type_of_number, tvb, curr_offset, 1, ENC_BIG_ENDIAN);\n\tproto_tree_add_item(tree, hf_gsm_a_dtap_numbering_plan_id, tvb, curr_offset, 1, ENC_BIG_ENDIAN);\n\tcurr_offset++;\n\n\tif (!extension)\n\t{\n\t\tproto_tree_add_item(tree, hf_gsm_a_extension, tvb, curr_offset, 1, ENC_BIG_ENDIAN);\n\t\tproto_tree_add_item(tree, hf_gsm_a_dtap_present_ind, tvb, curr_offset, 1, ENC_BIG_ENDIAN);\n\t\tproto_tree_add_bits_item(tree, hf_gsm_a_spare_bits, tvb, (curr_offset<<3)+3, 3, ENC_BIG_ENDIAN);\n\t\tproto_tree_add_item(tree, hf_gsm_a_dtap_screening_ind, tvb, curr_offset, 1, ENC_BIG_ENDIAN);\n\t\tcurr_offset++;\n\t}\n\n\tNO_MORE_DATA_CHECK(len);\n\n\tnum_string_len = len - (curr_offset - offset);\n\tpoctets = (guint8 *)tvb_memdup(wmem_packet_scope(), tvb, curr_offset, num_string_len);\n\n\t*address_extracted = TRUE;\n\tmy_dgt_tbcd_unpack(a_bigbuf, poctets, num_string_len,\n\t\t&Dgt_mbcd);\n\n    digit_str = tvb_bcd_dig_to_wmem_packet_str(tvb, curr_offset, num_string_len, NULL, FALSE);\n    item = proto_tree_add_string(tree, header_field, tvb, curr_offset, num_string_len, digit_str);\n\titem = proto_tree_add_string_format(tree, header_field,\n\t\ttvb, curr_offset, num_string_len,\n\t\ta_bigbuf,\n\t\t\"BCD Digits: %s\",\n\t\ta_bigbuf);\n\n    \/* Check for overdicadic digits, we used the standard digit map from tvbuff.c\n               *  0   1   2   3   4   5   6   7   8   9   a   b   c   d   e  f\n               * '0','1','2','3','4','5','6','7','8','9','?','?','?','?','?','?'\n        *\n        *\/\n    if(strchr(digit_str,'?')){\n\t\texpert_add_info(pinfo, item, &ei_gsm_a_dtap_end_mark_unexpected);\n    }\n\n\treturn(len);\n}\n","0_CVE_2015_6243_PATCHED_dissector_get_default_string_handle":"dissector_handle_t\nCVE_2015_6243_PATCHED_dissector_get_default_string_handle(const char *name, const gchar *string)\n{\n       dissector_table_t sub_dissectors;\n\n       if (!string) return 0;\n       sub_dissectors = find_dissector_table(name);\n\tif (sub_dissectors != NULL) {\n\t\tdtbl_entry_t *dtbl_entry = find_string_dtbl_entry(sub_dissectors, string);\n\t\tif (dtbl_entry != NULL)\n\t\t\treturn dtbl_entry->initial;\n\t}\n\treturn NULL;\n}\n","0_CVE_2015_6243_PATCHED_dissector_get_string_handle":"dissector_handle_t\nCVE_2015_6243_PATCHED_dissector_get_string_handle(dissector_table_t sub_dissectors,\n\t\t\t    const gchar *string)\n{\n\tdtbl_entry_t *dtbl_entry;\n\n       if (!string) return 0;\n\tdtbl_entry = find_string_dtbl_entry(sub_dissectors, string);\n\tif (dtbl_entry != NULL)\n\t\treturn dtbl_entry->current;\n\telse\n\t\treturn NULL;\n}\n","0_CVE_2015_6246_PATCHED_dissect_wa_payload":"static void CVE_2015_6246_PATCHED_dissect_wa_payload(guint32 starting_offset, proto_item *parent_tree, tvbuff_t *tvb, guint32 control_word, guint8 version)\n{\n    switch (control_word)\n    {\n        case 0x11:   \/* Flow start message *\/\n            proto_tree_add_item(parent_tree,\n                hf_waveagent_payfill, tvb, starting_offset, 4, ENC_BIG_ENDIAN);\n\n            proto_tree_add_item(parent_tree,\n                hf_waveagent_paysize, tvb, starting_offset+4, 4, ENC_BIG_ENDIAN);\n\n            proto_tree_add_item(parent_tree,\n                hf_waveagent_avgrate, tvb, starting_offset+8, 4, ENC_BIG_ENDIAN);\n\n            proto_tree_add_item(parent_tree,\n                hf_waveagent_totalframes, tvb, starting_offset+12, 4, ENC_BIG_ENDIAN);\n\n            break;\n\n        case 0x23:   \/* Scan results request *\/\n            proto_tree_add_item(parent_tree,\n                hf_waveagent_ifindex, tvb, starting_offset, 4, ENC_BIG_ENDIAN);\n\n            proto_tree_add_item(parent_tree,\n                hf_waveagent_bssidstartindex, tvb, starting_offset+4, 4, ENC_BIG_ENDIAN);\n\n            proto_tree_add_item(parent_tree,\n                hf_waveagent_bssidstopindex, tvb, starting_offset+8, 4, ENC_BIG_ENDIAN);\n\n            break;\n\n        case 0x24:   \/* Interface info request *\/\n        case 0x25:   \/* Interface change info request *\/\n        case 0x8a:   \/* Scan request *\/\n            proto_tree_add_item(parent_tree,\n                hf_waveagent_ifindex, tvb, starting_offset, 4, ENC_BIG_ENDIAN);\n\n            break;\n\n        case 0x26:   \/* OID request *\/\n            proto_tree_add_item(parent_tree,\n                hf_waveagent_ifindex, tvb, starting_offset, 4, ENC_BIG_ENDIAN);\n\n            proto_tree_add_item(parent_tree,\n                hf_waveagent_oidcode, tvb, starting_offset+4, 4, ENC_BIG_ENDIAN);\n\n            break;\n\n        case 0x30: {  \/* Interface stats response *\/\n            guint32 if_type;\n\n            proto_tree_add_item(parent_tree,\n                hf_waveagent_ifindex, tvb, starting_offset, 4, ENC_BIG_ENDIAN);\n\n            if_type = tvb_get_ntohl(tvb, starting_offset + 4);\n\n            proto_tree_add_item(parent_tree,\n                hf_waveagent_iftype, tvb, starting_offset + 4, 4, ENC_BIG_ENDIAN);\n\n            proto_tree_add_item(parent_tree,\n                hf_waveagent_ifdhcp, tvb, starting_offset + 8, 4, ENC_BIG_ENDIAN);\n\n            proto_tree_add_item(parent_tree,\n                hf_waveagent_ifmacaddr, tvb, starting_offset + 12, 6, ENC_NA);\n\n            \/* 2 bytes of pad go here *\/\n\n            proto_tree_add_item(parent_tree,\n                hf_waveagent_iflinkspeed, tvb, starting_offset + 20, 4, ENC_BIG_ENDIAN);\n\n            proto_tree_add_item(parent_tree,\n                hf_waveagent_ifdescription, tvb, starting_offset + 24, 128, ENC_ASCII|ENC_NA);\n\n            \/* 4 byte length field goes here - skip it *\/\n\n            \/* two bytes of pad go here *\/\n\n            \/* If we have WLAN interface, then report the following *\/\n            if (if_type == WLAN_INTERFACE)\n                dissect_wlan_if_stats(starting_offset + 156, parent_tree, tvb);\n\n            \/* Next come the BindingAddress fields (for each address):\n                2 bytes:  IP type (v4 or v6)\n                2 bytes:  address length\n                4 bytes:  service number (not used)\n                16 bytes: IP address     *\/\n\n            \/* for the bound IP address, report both IP type and address *\/\n\n            proto_tree_add_item(parent_tree,\n                hf_waveagent_ifiptype, tvb, starting_offset + 252, 2, ENC_BIG_ENDIAN);\n\n            if (tvb_get_ntohs(tvb, starting_offset + 252) == IPV4_TYPE) {\n                proto_tree_add_item(parent_tree,\n                    hf_waveagent_ifipv4, tvb, starting_offset + 260, 4, ENC_BIG_ENDIAN);  \/* grab the last 4 bytes of the IP address field *\/\n            }\n            else {\n                proto_tree_add_item(parent_tree,\n                    hf_waveagent_ifipv6, tvb, starting_offset + 260, 16, ENC_NA);\n            }\n\n            proto_tree_add_item(parent_tree,\n                hf_waveagent_ifdhcpserver, tvb, starting_offset + 284, 4, ENC_BIG_ENDIAN);\n\n            proto_tree_add_item(parent_tree,\n                hf_waveagent_ifgateway,    tvb, starting_offset + 308, 4, ENC_BIG_ENDIAN);\n\n            proto_tree_add_item(parent_tree,\n                hf_waveagent_ifdnsserver,  tvb, starting_offset + 332, 4, ENC_BIG_ENDIAN);\n\n            break;\n        }\n\n        case 0x31:  {  \/* Interface change info response *\/\n            guint32 offset;\n            guint32 if_type;\n            guint32 delta;\n            guint32 iLoop;\n\n            proto_tree_add_item(parent_tree,\n                hf_waveagent_ifindex, tvb, starting_offset, 4, ENC_BIG_ENDIAN);\n\n            if_type = tvb_get_ntohl(tvb, starting_offset + 4);\n\n            proto_tree_add_item(parent_tree,\n                hf_waveagent_iftype, tvb, starting_offset + 4, 4, ENC_BIG_ENDIAN);\n\n            offset = starting_offset + 8;\n            delta = 156;\n\n            for (iLoop = 0; iLoop < NUM_STATE_CHANGES; iLoop++) {\n                proto_item *stIndex;\n                proto_tree *st_change_index_tree;\n                guint32     if_status;\n                int         current_offset;\n\n                current_offset = offset + iLoop * delta;\n\n                \/* Check to see if the interface entry is valid *\/\n                if_status = tvb_get_ntohl(tvb, current_offset);\n                if (if_status == 0) continue;  \/* No entry at this index, keep going *\/\n\n                \/* Add index specific trees to hide the details *\/\n                stIndex = proto_tree_add_uint_format_value(parent_tree,\n                    hf_waveagent_ifwlanl2status, tvb, current_offset, 4, if_status, \"Interface state change %d\", iLoop);\n\n                st_change_index_tree = proto_item_add_subtree(stIndex, ett_scindex[iLoop]);\n\n                if (if_type == WLAN_INTERFACE) {\n                    proto_tree_add_item(st_change_index_tree,\n                        hf_waveagent_ifwlanl2status, tvb, current_offset, 4, ENC_BIG_ENDIAN);\n                } else {\n                    proto_tree_add_item(st_change_index_tree,\n                        hf_waveagent_ifethl2status, tvb, current_offset, 4, ENC_BIG_ENDIAN);\n                }\n\n                proto_tree_add_item(st_change_index_tree,\n                    hf_waveagent_ifl3status, tvb, current_offset + 4, 4, ENC_BIG_ENDIAN);\n\n                proto_tree_add_item(st_change_index_tree,\n                    hf_waveagent_iflinkspeed, tvb, current_offset + 8, 4, ENC_BIG_ENDIAN);\n\n                if (if_type == WLAN_INTERFACE) {\n                    dissect_wlan_if_stats(current_offset + 12, st_change_index_tree, tvb);\n                }\n\n                proto_tree_add_item(st_change_index_tree,\n                    hf_waveagent_snap, tvb, current_offset + 108, 8, ENC_BIG_ENDIAN);\n\n                proto_tree_add_item(st_change_index_tree,\n                    hf_waveagent_ifiptype, tvb, current_offset + 116, 2, ENC_BIG_ENDIAN);\n\n                if (tvb_get_ntohs(tvb, current_offset + 116) == IPV4_TYPE) {\n                    proto_tree_add_item(st_change_index_tree,\n                        hf_waveagent_ifipv4, tvb, current_offset + 124, 4, ENC_BIG_ENDIAN);  \/* grab the last 4 bytes of the IP address field *\/\n                }\n                else {\n                    proto_tree_add_item(st_change_index_tree,\n                        hf_waveagent_ifipv6, tvb, current_offset + 124, 16, ENC_NA);\n                }\n\n                \/* 16 bytes of padding *\/\n            }\n\n            break;\n        }\n\n        case 0x32:   \/* OID response *\/\n            proto_tree_add_item(parent_tree,\n                hf_waveagent_ifindex, tvb, starting_offset, 4, ENC_BIG_ENDIAN);\n\n            proto_tree_add_item(parent_tree,\n                hf_waveagent_oidcode, tvb, starting_offset + 4, 4, ENC_BIG_ENDIAN);\n\n            proto_tree_add_item(parent_tree,\n                hf_waveagent_oidvalue, tvb, starting_offset + 12, 1024, ENC_ASCII|ENC_NA);\n\n            break;\n\n        case 0x2e: {  \/* scan results response message *\/\n            guint32        offset;\n            proto_item    *pi;\n            guint32        num_bss_entries;\n            guint32        tag_len;\n            guint32        delta;\n            guint32        iLoop;\n            wmem_strbuf_t *sb;\n\n            proto_tree_add_item(parent_tree,\n                hf_waveagent_ifindex, tvb, starting_offset, 4, ENC_BIG_ENDIAN);\n\n\n            proto_tree_add_item(parent_tree,\n                hf_waveagent_totalbssid, tvb, starting_offset + 4, 4, ENC_BIG_ENDIAN);\n\n            pi = proto_tree_add_item(parent_tree,\n                hf_waveagent_returnedbssid, tvb, starting_offset + 8, 4, ENC_BIG_ENDIAN);\n\n            num_bss_entries = tvb_get_ntohl(tvb, starting_offset + 8);\n\n            if (num_bss_entries > NUM_BSS) {\n                proto_item_append_text(pi, \" [**Too large: Limiting to \" G_STRINGIFY(NUM_BSS) \"]\");\n                num_bss_entries = NUM_BSS;\n            }\n            \/* Add 4 bytes of pad for the offset *\/\n\n            offset = starting_offset + 16;\n            delta  = 148;\n\n            sb = wmem_strbuf_sized_new(wmem_packet_scope(), 8, SHORT_STR);\n\n            for (iLoop = 0; iLoop < num_bss_entries; iLoop++)\n            {\n                proto_item *bssIndex;\n                proto_tree *bss_tree;\n                int         current_offset;\n\n                wmem_strbuf_truncate(sb, 0);\n\n                current_offset = offset + iLoop * delta;\n\n                bssIndex = proto_tree_add_item(parent_tree,\n                    hf_waveagent_scanssid, tvb, current_offset, 32, ENC_ASCII|ENC_NA);\n\n                bss_tree = proto_item_add_subtree(bssIndex, ett_bss[iLoop]);\n\n                tag_len = tvb_get_ntohl(tvb, current_offset + 52);\n\n                if (tag_len != 0) {\n                    guint32       isr;\n                    guint8        isr_value;\n\n                    for (isr = 0; isr < tag_len; isr++) {\n                        isr_value = tvb_get_guint8(tvb, offset + 36 + isr);\n                        if (isr_value == 0xFF){\n                            proto_tree_add_string (bss_tree, hf_waveagent_ifwlansupprates, tvb, offset + 36 + isr,\n                                                   1,\n                                                   \"BSS requires support for mandatory features of HT PHY (IEEE 802.11\"\n                                                   \" - Clause 20)\");\n                        } else {\n                            wmem_strbuf_append_printf(sb, \"%2.1f%s \",\n                                      (isr_value & 0x7F) * 0.5,\n                                      (isr_value & 0x80) ? \"(B)\" : \"\");\n\n                        }\n                    }\n                    wmem_strbuf_append(sb, \" [Mbit\/sec]\");\n                }\n                else {\n                    wmem_strbuf_append(sb, \"Not defined\");\n                }\n\n                proto_tree_add_string (bss_tree, hf_waveagent_ifwlansupprates, tvb, offset + 36,\n                    tag_len, wmem_strbuf_get_str(sb));\n\n                proto_tree_add_item(bss_tree,\n                    hf_waveagent_scanbssid, tvb, current_offset + 56, 6, ENC_NA);\n\n                proto_tree_add_item(bss_tree,\n                    hf_waveagent_ifwlancapabilities, tvb, current_offset + 62, 2, ENC_BIG_ENDIAN);\n\n                proto_tree_add_item(bss_tree,\n                    hf_waveagent_ifwlanrssi, tvb, current_offset + 64, 4, ENC_BIG_ENDIAN);\n\n                \/*  For now this is just a 4 byte pad, so comment it out...  *\/\n#if 0\n                proto_tree_add_item(bss_tree,\n                    hf_waveagent_ifwlansigquality, tvb, current_offset + 68, 4, ENC_BIG_ENDIAN);\n#endif\n                proto_tree_add_item(bss_tree,\n                    hf_waveagent_ifwlanchannel, tvb, current_offset + 72, 4, ENC_BIG_ENDIAN);\n\n                proto_tree_add_item(bss_tree,\n                    hf_waveagent_ifwlanprivacy, tvb, current_offset + 76, 4, ENC_BIG_ENDIAN);\n\n                proto_tree_add_item(bss_tree,\n                    hf_waveagent_ifwlanbssmode, tvb, current_offset + 80, 4, ENC_BIG_ENDIAN);\n            }\n            break;\n        }\n\n        case 0x2f:   \/* Stats response message *\/\n            if (version < 3) {\n                \/* For version 2 WA protocol the capability status is not in the header but in the CAP\n                   RESPONSE.  Need to read it here and then advance the payload offset.  This is a\n                   packet that had a structure change in the beginning of the packet when moving\n                   to v3 *\/\n                proto_tree_add_item(parent_tree,\n                    hf_waveagent_capstatus, tvb, starting_offset, 4, ENC_BIG_ENDIAN);\n\n                proto_tree_add_item(parent_tree,\n                    hf_waveagent_protocolversion, tvb, starting_offset, 1, ENC_BIG_ENDIAN);\n\n                starting_offset += 4;\n            }\n\n            proto_tree_add_item(parent_tree,\n                hf_waveagent_capimpl, tvb, starting_offset, 4, ENC_BIG_ENDIAN);\n\n            proto_tree_add_item(parent_tree,\n                       hf_waveagent_state, tvb, starting_offset + 4, 4, ENC_BIG_ENDIAN);\n\n            proto_tree_add_item(parent_tree,\n                       hf_waveagent_appstate, tvb, starting_offset + 8, 4, ENC_BIG_ENDIAN);\n\n            proto_tree_add_item(parent_tree,\n                hf_waveagent_rxdatapckts, tvb, starting_offset + 12, 8, ENC_BIG_ENDIAN);\n\n            proto_tree_add_item(parent_tree,\n                hf_waveagent_rxdatabytes, tvb, starting_offset + 20, 8, ENC_BIG_ENDIAN);\n\n            proto_tree_add_item(parent_tree,\n                hf_waveagent_rxpcktrate, tvb, starting_offset + 28, 8, ENC_BIG_ENDIAN);\n\n            proto_tree_add_item(parent_tree,\n                hf_waveagent_rxbyterate, tvb, starting_offset + 36, 8, ENC_BIG_ENDIAN);\n\n            proto_tree_add_item(parent_tree,\n                hf_waveagent_txdatapckts, tvb, starting_offset + 44, 8, ENC_BIG_ENDIAN);\n\n            proto_tree_add_item(parent_tree,\n                hf_waveagent_txdatabytes, tvb, starting_offset + 52, 8, ENC_BIG_ENDIAN);\n\n            proto_tree_add_item(parent_tree,\n                hf_waveagent_txpcktrate, tvb, starting_offset + 60, 8, ENC_BIG_ENDIAN);\n\n            proto_tree_add_item(parent_tree,\n                hf_waveagent_txbyterate, tvb, starting_offset + 68, 8, ENC_BIG_ENDIAN);\n\n            proto_tree_add_item(parent_tree,\n                hf_waveagent_looppckts, tvb, starting_offset + 76, 8, ENC_BIG_ENDIAN);\n\n            proto_tree_add_item(parent_tree,\n                hf_waveagent_loopbytes, tvb, starting_offset + 84, 8, ENC_BIG_ENDIAN);\n\n            proto_tree_add_item(parent_tree,\n                hf_waveagent_rxctlpckts, tvb, starting_offset + 92, 8, ENC_BIG_ENDIAN);\n\n            proto_tree_add_item(parent_tree,\n                hf_waveagent_rxctlbytes, tvb, starting_offset + 100, 8, ENC_BIG_ENDIAN);\n\n            proto_tree_add_item(parent_tree,\n                hf_waveagent_txctlpckts, tvb, starting_offset + 108, 8, ENC_BIG_ENDIAN);\n\n            proto_tree_add_item(parent_tree,\n                hf_waveagent_txctlbytes, tvb, starting_offset + 116, 8, ENC_BIG_ENDIAN);\n\n            proto_tree_add_item(parent_tree,\n                hf_waveagent_unknowncmds, tvb, starting_offset + 124, 8, ENC_BIG_ENDIAN);\n\n            proto_tree_add_item(parent_tree,\n                hf_waveagent_snap, tvb, starting_offset + 132, 8, ENC_BIG_ENDIAN);\n\n#if 0\n            proto_tree_add_item(parent_tree,\n                hf_waveagent_tstamp1, tvb, 140, 4, ENC_BIG_ENDIAN);\n\n            proto_tree_add_item(parent_tree,\n                hf_waveagent_tstamp2, tvb, 144, 4, ENC_BIG_ENDIAN);\n\n            proto_tree_add_item(parent_tree,\n                hf_waveagent_tstamp3, tvb, 148, 4, ENC_BIG_ENDIAN);\n\n            proto_tree_add_item(parent_tree,\n                hf_waveagent_tstamp4, tvb, 152, 4, ENC_BIG_ENDIAN);\n\n            proto_tree_add_item(parent_tree,\n                hf_waveagent_tstamp5, tvb, 156, 4, ENC_BIG_ENDIAN);\n\n            proto_tree_add_item(parent_tree,\n                hf_waveagent_tstamp6, tvb, 160, 4, ENC_BIG_ENDIAN);\n\n            proto_tree_add_item(parent_tree,\n                hf_waveagent_tstamp7, tvb, 164, 4, ENC_BIG_ENDIAN);\n\n            proto_tree_add_item(parent_tree,\n                hf_waveagent_tstamp8, tvb, 168, 4, ENC_BIG_ENDIAN);\n\n            proto_tree_add_item(parent_tree,\n                hf_waveagent_minlcldelta, tvb, 172, 4, ENC_BIG_ENDIAN);\n\n            proto_tree_add_item(parent_tree,\n                hf_waveagent_maxlcldelta, tvb, 176, 4, ENC_BIG_ENDIAN);\n\n            proto_tree_add_item(parent_tree,\n                hf_waveagent_avglcldelta, tvb, 180, 4, ENC_BIG_ENDIAN);\n\n            proto_tree_add_item(parent_tree,\n                hf_waveagent_minremdelta, tvb, 184, 4, ENC_BIG_ENDIAN);\n\n            proto_tree_add_item(parent_tree,\n                hf_waveagent_maxremdelta, tvb, 188, 4, ENC_BIG_ENDIAN);\n\n            proto_tree_add_item(parent_tree,\n                hf_waveagent_avgremdelta, tvb, 192, 4, ENC_BIG_ENDIAN);\n#endif\n            proto_tree_add_item(parent_tree,\n                hf_waveagent_rx1pl, tvb, starting_offset + 284, 8, ENC_BIG_ENDIAN);\n\n            proto_tree_add_item(parent_tree,\n                hf_waveagent_rx2pl, tvb, starting_offset + 292, 8, ENC_BIG_ENDIAN);\n\n            proto_tree_add_item(parent_tree,\n                hf_waveagent_rx3pl, tvb, starting_offset + 300, 8, ENC_BIG_ENDIAN);\n\n            proto_tree_add_item(parent_tree,\n                hf_waveagent_rx4pl, tvb, starting_offset + 308, 8, ENC_BIG_ENDIAN);\n\n            proto_tree_add_item(parent_tree,\n                hf_waveagent_rx5pl, tvb, starting_offset + 316, 8, ENC_BIG_ENDIAN);\n\n            proto_tree_add_item(parent_tree,\n                hf_waveagent_rxoospkts, tvb, starting_offset + 324, 8, ENC_BIG_ENDIAN);\n\n            proto_tree_add_item(parent_tree,\n                hf_waveagent_jitter, tvb, starting_offset + 356, 8, ENC_BIG_ENDIAN);\n\n            if (version >= 3) {\n                proto_tree_add_item(parent_tree,\n                    hf_waveagent_delayfactor, tvb, starting_offset + 364, 8, ENC_BIG_ENDIAN);\n\n                proto_tree_add_item(parent_tree,\n                    hf_waveagent_medialossrate, tvb, starting_offset + 372, 8, ENC_BIG_ENDIAN);\n\n                proto_tree_add_item(parent_tree,\n                    hf_waveagent_txstartts, tvb, starting_offset + 380, 8, ENC_BIG_ENDIAN);\n\n                proto_tree_add_item(parent_tree,\n                    hf_waveagent_txendts, tvb, starting_offset + 388, 8, ENC_BIG_ENDIAN);\n\n                proto_tree_add_item(parent_tree,\n                    hf_waveagent_rxstartts, tvb, starting_offset + 396, 8, ENC_BIG_ENDIAN);\n\n                proto_tree_add_item(parent_tree,\n                    hf_waveagent_rxendts, tvb, starting_offset + 404, 8, ENC_BIG_ENDIAN);\n\n                proto_tree_add_item(parent_tree,\n                    hf_waveagent_latencysum, tvb, starting_offset + 412, 8, ENC_BIG_ENDIAN);\n\n                proto_tree_add_item(parent_tree,\n                    hf_waveagent_latencycount, tvb, starting_offset + 420, 8, ENC_BIG_ENDIAN);\n\n                proto_tree_add_item(parent_tree,\n                    hf_waveagent_txflowstop, tvb, starting_offset + 428, 8, ENC_BIG_ENDIAN);\n            }\n\n            break;\n\n        case 0x40: {\n            guint32 offset;\n            guint32 delta;\n            guint32 iLoop;\n            guint32 num_bss_entries;\n\n            proto_tree_add_item(parent_tree,\n                hf_waveagent_ifindex, tvb, starting_offset, 4, ENC_BIG_ENDIAN);\n\n            proto_tree_add_item(parent_tree,\n                hf_waveagent_connectflags, tvb, starting_offset + 4, 4, ENC_BIG_ENDIAN);\n\n            proto_tree_add_item(parent_tree,\n                hf_waveagent_connecttype, tvb, starting_offset + 8, 4, ENC_BIG_ENDIAN);\n\n            proto_tree_add_item(parent_tree,\n                hf_waveagent_scanssid, tvb, starting_offset + 12, 32, ENC_ASCII|ENC_NA);\n\n            num_bss_entries = tvb_get_ntohl(tvb, starting_offset + 142);\n\n            offset = starting_offset + 46;\n            delta = 6;\n            for (iLoop = 0; iLoop < num_bss_entries; iLoop++)\n            {\n                int current_offset;\n                current_offset = offset + iLoop * delta;\n\n                proto_tree_add_item(parent_tree,\n                    hf_waveagent_scanbssid, tvb, current_offset, 6, ENC_NA);\n            }\n\n            proto_tree_add_item(parent_tree,\n                hf_waveagent_minrssi, tvb, starting_offset + 146, 4, ENC_BIG_ENDIAN);\n\n            proto_tree_add_item(parent_tree,\n                hf_waveagent_connecttimeout, tvb, starting_offset + 150, 4, ENC_BIG_ENDIAN);\n\n            proto_tree_add_item(parent_tree,\n                hf_waveagent_connectattempts, tvb, starting_offset + 154, 4, ENC_BIG_ENDIAN);\n\n            break;\n        }\n\n        case 0x41:\n            proto_tree_add_item(parent_tree,\n                hf_waveagent_ifindex, tvb, starting_offset, 4, ENC_BIG_ENDIAN);\n\n            proto_tree_add_item(parent_tree,\n                hf_waveagent_reason, tvb, starting_offset + 4, 4, ENC_BIG_ENDIAN);\n\n            break;\n\n        case 0x81:   \/* Capabilities response *\/\n            if (version < 3) {\n                \/* For version 2 WA protocol the capability status is not in the header but in the CAP\n                   RESPONSE.  Need to read it here and then advance the payload offset.  This is a\n                   packet that had a structure change in the beginning of the packet when moving\n                   to v3 *\/\n                proto_tree_add_item(parent_tree,\n                    hf_waveagent_capstatus, tvb, starting_offset, 4, ENC_BIG_ENDIAN);\n\n                proto_tree_add_item(parent_tree,\n                    hf_waveagent_protocolversion, tvb, starting_offset, 1, ENC_BIG_ENDIAN);\n\n                starting_offset += 4;\n            }\n\n            proto_tree_add_item(parent_tree,\n                hf_waveagent_capimpl, tvb, starting_offset, 4, ENC_BIG_ENDIAN);\n\n            proto_tree_add_item(parent_tree,\n                hf_waveagent_id, tvb, starting_offset + 4, 128, ENC_ASCII|ENC_NA);\n\n            proto_tree_add_item(parent_tree,\n                hf_waveagent_bindtag, tvb, starting_offset + 136, 128, ENC_ASCII|ENC_NA);\n\n            proto_tree_add_item(parent_tree,\n                hf_waveagent_version, tvb, starting_offset + 268, 128, ENC_ASCII|ENC_NA);\n\n            proto_tree_add_item(parent_tree,\n                hf_waveagent_brokerip, tvb, starting_offset + 400, 4, ENC_BIG_ENDIAN);\n\n            proto_tree_add_item(parent_tree,\n                hf_waveagent_brokerport, tvb, starting_offset + 404, 4, ENC_BIG_ENDIAN);\n\n            proto_tree_add_item(parent_tree,\n                hf_waveagent_bindlevel, tvb, starting_offset + 408, 4, ENC_BIG_ENDIAN);\n\n            proto_tree_add_item(parent_tree,\n                hf_waveagent_bindport, tvb, starting_offset + 412, 4, ENC_BIG_ENDIAN);\n\n            if (version >= 3) {\n                proto_tree_add_item(parent_tree,\n                    hf_waveagent_capabilities2, tvb, starting_offset + 416, 4, ENC_BIG_ENDIAN);\n\n                proto_tree_add_item(parent_tree,\n                    hf_waveagent_numinterfaces, tvb, starting_offset + 420, 4, ENC_BIG_ENDIAN);\n\n                proto_tree_add_item(parent_tree,\n                    hf_waveagent_ifmask, tvb, starting_offset + 424, 4, ENC_BIG_ENDIAN);\n            }\n\n            break;\n\n        case 0x82:    \/* Reserve request *\/\n            proto_tree_add_item(parent_tree,\n                hf_waveagent_bindtag, tvb, starting_offset, 128, ENC_ASCII|ENC_NA);\n\n            proto_tree_add_item(parent_tree,\n                hf_waveagent_brokerip, tvb, starting_offset + 132, 4, ENC_BIG_ENDIAN);\n\n            proto_tree_add_item(parent_tree,\n                hf_waveagent_brokerport, tvb, starting_offset + 136, 4, ENC_BIG_ENDIAN);\n\n            break;\n\n        case 0x85: {   \/* Flow setup *\/\n            proto_tree *fs_flags;\n            proto_tree *fs_flags_tree;\n            guint32     flags_bitfield;\n\n            if (version < 3) {\n                proto_tree_add_item(parent_tree,\n                    hf_waveagent_rxflownum, tvb, starting_offset, 4, ENC_BIG_ENDIAN);\n            }\n\n            proto_tree_add_item(parent_tree,\n                hf_waveagent_mode, tvb, starting_offset + 7, 1, ENC_BIG_ENDIAN);\n\n            proto_tree_add_item(parent_tree,\n                hf_waveagent_endpointtype, tvb, starting_offset + 7, 1, ENC_BIG_ENDIAN);\n\n            proto_tree_add_item(parent_tree,\n                hf_waveagent_bindport, tvb, starting_offset + 8, 4, ENC_BIG_ENDIAN);\n\n            proto_tree_add_item(parent_tree,\n                hf_waveagent_bindlevel, tvb, starting_offset + 12, 4, ENC_BIG_ENDIAN);\n\n            proto_tree_add_item(parent_tree,\n                hf_waveagent_remoteport, tvb, starting_offset + 16, 4, ENC_BIG_ENDIAN);\n\n            proto_tree_add_item(parent_tree,\n                hf_waveagent_remoteaddr, tvb, starting_offset + 24, 4, ENC_BIG_ENDIAN);\n\n            proto_tree_add_item(parent_tree,\n                hf_waveagent_dscp, tvb, starting_offset + 40, 4, ENC_BIG_ENDIAN);\n\n            flags_bitfield = tvb_get_ntohl(tvb, starting_offset + 44);\n\n            fs_flags = proto_tree_add_uint(parent_tree, hf_waveagent_fsflags,\n                                        tvb, starting_offset + 44, 4, flags_bitfield);\n\n            fs_flags_tree = proto_item_add_subtree(fs_flags, ett_fsflags);\n\n            proto_tree_add_item(fs_flags_tree,\n                    hf_waveagent_fscbrflag, tvb, starting_offset + 47, 1, ENC_LITTLE_ENDIAN);\n\n            proto_tree_add_item(fs_flags_tree,\n                    hf_waveagent_fscombinedsetupflag, tvb, starting_offset + 47, 1, ENC_LITTLE_ENDIAN);\n\n            if (version >= 3) {\n                proto_tree_add_item(parent_tree,\n                    hf_waveagent_ifindex, tvb, starting_offset + 48, 4, ENC_BIG_ENDIAN);\n\n                proto_tree_add_item(parent_tree,\n                    hf_waveagent_payfill, tvb, starting_offset + 52, 4, ENC_BIG_ENDIAN);\n\n                proto_tree_add_item(parent_tree,\n                    hf_waveagent_paysize, tvb, starting_offset + 56, 4, ENC_BIG_ENDIAN);\n\n                proto_tree_add_item(parent_tree,\n                    hf_waveagent_avgrate, tvb, starting_offset + 60, 4, ENC_BIG_ENDIAN);\n\n                proto_tree_add_item(parent_tree,\n                    hf_waveagent_totalframes, tvb, starting_offset + 64, 4, ENC_BIG_ENDIAN);\n            }\n\n            break;\n        }\n\n        case 0x8b:\n            proto_tree_add_item(parent_tree,\n                hf_waveagent_destip, tvb, starting_offset, 4, ENC_BIG_ENDIAN);\n\n            proto_tree_add_item(parent_tree,\n                hf_waveagent_destport, tvb, starting_offset + 4, 4, ENC_BIG_ENDIAN);\n\n            proto_tree_add_item(parent_tree,\n                hf_waveagent_connectflags, tvb, starting_offset + 8, 4, ENC_BIG_ENDIAN);\n\n            break;\n\n        case 0x3f:  \/* Relay response *\/\n        case 0x8f:  \/* Command Response *\/\n            proto_tree_add_item(parent_tree,\n                hf_waveagent_commandstatus, tvb, starting_offset, 4, ENC_BIG_ENDIAN);\n\n            proto_tree_add_item(parent_tree,\n                hf_waveagent_syserrno, tvb, starting_offset + 4, 4, ENC_BIG_ENDIAN);\n\n            proto_tree_add_item(parent_tree,\n                hf_waveagent_statusstring, tvb, starting_offset + 8, 128, ENC_ASCII|ENC_NA);\n\n            break;\n    }\n}\n","0_CVE_2015_6249_PATCHED_dissect_wccp2r1_address_table_info":"static gint\nCVE_2015_6249_PATCHED_dissect_wccp2r1_address_table_info(tvbuff_t *tvb, int offset, int length,\n                                   packet_info *pinfo, proto_tree *info_tree)\n{\n  guint16 address_length;\n  guint32 i;\n  gint16 family;\n  guint16 table_length;\n  proto_tree *element_tree;\n  proto_item *tf;\n\n  if (info_tree)\n    tf = proto_tree_get_parent(info_tree);\n\n  if (length < 2*4)\n    return length - 2*4;\n\n  family = tvb_get_ntohs(tvb, offset);\n  proto_tree_add_item(info_tree, hf_address_table_family, tvb, offset, 2, ENC_BIG_ENDIAN);\n  EAT_AND_CHECK(2,2);\n\n  address_length = tvb_get_ntohs(tvb, offset);\n  proto_tree_add_item(info_tree, hf_address_table_address_length, tvb, offset, 2, ENC_BIG_ENDIAN);\n  EAT_AND_CHECK(2,2);\n\n  table_length =  tvb_get_ntohl(tvb, offset);\n  tf = proto_tree_add_item(info_tree, hf_address_table_length, tvb, offset, 4, ENC_BIG_ENDIAN);\n  element_tree = proto_item_add_subtree(tf, ett_table_element);\n  EAT(4);\n\n  if (wccp_wccp_address_table.in_use == FALSE) {\n    wccp_wccp_address_table.family = family;\n    wccp_wccp_address_table.table_length =  table_length;\n\n    \/* check if the length is valid and allocate the tables if needed *\/\n    switch (wccp_wccp_address_table.family) {\n    case 1:\n      if (wccp_wccp_address_table.table_ipv4 == NULL)\n        wccp_wccp_address_table.table_ipv4 = (guint32 *)\n          wmem_alloc0(pinfo->pool, wccp_wccp_address_table.table_length * 4);\n      if (address_length != 4) {\n        expert_add_info_format(pinfo, tf, &ei_wccp_length_bad,\n                               \"The Address length must be 4, but I found %d for IPv4 addresses. Correcting this.\",\n                               address_length);\n        address_length = 4;\n      }\n      break;\n    case 2:\n      if (wccp_wccp_address_table.table_ipv6 == NULL)\n        wccp_wccp_address_table.table_ipv6 = (struct e_in6_addr *)\n          wmem_alloc0(pinfo->pool, wccp_wccp_address_table.table_length * sizeof(struct e_in6_addr));\n      if (address_length != 16) {\n        expert_add_info_format(pinfo, tf, &ei_wccp_length_bad,\n                               \"The Address length must be 16, but I found %d for IPv6 addresses. Correcting this.\",\n                               address_length);\n        address_length = 16;\n      }\n      break;\n    default:\n      expert_add_info_format(pinfo, tf, &ei_wccp_address_table_family_unknown,\n                      \"Unknown address family: %d\", wccp_wccp_address_table.family);\n    };\n  }\n\n  \/* now read the addresses and print\/store them *\/\n\n  for(i=0; i<table_length; i++) {\n    const gchar *addr;\n\n    switch (family) {\n    case 1:\n      \/* IPv4 *\/\n      addr  =  tvb_ip_to_str(tvb, offset);\n      if ((wccp_wccp_address_table.in_use == FALSE) &&\n          (wccp_wccp_address_table.table_ipv4 != NULL) &&\n          ((address_length * i) < wccp_wccp_address_table.table_length))\n        wccp_wccp_address_table.table_ipv4[i] = tvb_get_ntohl(tvb, offset);\n      break;\n    case 2:\n      \/* IPv6 *\/\n      addr = tvb_ip6_to_str(tvb, offset);\n      if ((wccp_wccp_address_table.in_use == FALSE) &&\n          (wccp_wccp_address_table.table_ipv6 != NULL) &&\n          (i < wccp_wccp_address_table.table_length))\n        tvb_get_ipv6(tvb, offset, &(wccp_wccp_address_table.table_ipv6[i]));\n      break;\n    default:\n      addr = wmem_strdup_printf(wmem_packet_scope(), \"unknown family %d\", wccp_wccp_address_table.family);\n    };\n\n    if (element_tree) {\n      proto_item *pi;\n\n      pi = proto_tree_add_string_format_value(element_tree, hf_address_table_element, tvb,\n                                              offset, address_length, addr,\n                                              \"%d: %s\", i+1, addr);\n      if (i > wccp_wccp_address_table.table_length)\n        expert_add_info_format(pinfo, pi, &ei_wccp_length_bad, \"Ran out of space to store address\");\n    }\n    EAT(address_length);\n  }\n\n  wccp_wccp_address_table.in_use = TRUE;\n  return length;\n}\n","0_CVE_2015_6654_PATCHED_xenmem_add_to_physmap_one":"int CVE_2015_6654_PATCHED_xenmem_add_to_physmap_one(\n    struct domain *d,\n    unsigned int space,\n    domid_t foreign_domid,\n    unsigned long idx,\n    xen_pfn_t gpfn)\n{\n    unsigned long mfn = 0;\n    int rc;\n    p2m_type_t t;\n\n    switch ( space )\n    {\n    case XENMAPSPACE_grant_table:\n        spin_lock(&d->grant_table->lock);\n\n        if ( d->grant_table->gt_version == 0 )\n            d->grant_table->gt_version = 1;\n\n        if ( d->grant_table->gt_version == 2 &&\n                (idx & XENMAPIDX_grant_table_status) )\n        {\n            idx &= ~XENMAPIDX_grant_table_status;\n            if ( idx < nr_status_frames(d->grant_table) )\n                mfn = virt_to_mfn(d->grant_table->status[idx]);\n            else\n                return -EINVAL;\n        }\n        else\n        {\n            if ( (idx >= nr_grant_frames(d->grant_table)) &&\n                    (idx < max_nr_grant_frames) )\n                gnttab_grow_table(d, idx + 1);\n\n            if ( idx < nr_grant_frames(d->grant_table) )\n                mfn = virt_to_mfn(d->grant_table->shared_raw[idx]);\n            else\n                return -EINVAL;\n        }\n        \n        d->arch.grant_table_gpfn[idx] = gpfn;\n\n        t = p2m_ram_rw;\n\n        spin_unlock(&d->grant_table->lock);\n        break;\n    case XENMAPSPACE_shared_info:\n        if ( idx != 0 )\n            return -EINVAL;\n\n        mfn = virt_to_mfn(d->shared_info);\n        t = p2m_ram_rw;\n\n        break;\n    case XENMAPSPACE_gmfn_foreign:\n    {\n        struct domain *od;\n        struct page_info *page;\n        p2m_type_t p2mt;\n        od = rcu_lock_domain_by_any_id(foreign_domid);\n        if ( od == NULL )\n            return -ESRCH;\n\n        if ( od == d )\n        {\n            rcu_unlock_domain(od);\n            return -EINVAL;\n        }\n\n        rc = xsm_map_gmfn_foreign(XSM_TARGET, d, od);\n        if ( rc )\n        {\n            rcu_unlock_domain(od);\n            return rc;\n        }\n\n        \/* Take reference to the foreign domain page.\n         * Reference will be released in XENMEM_remove_from_physmap *\/\n        page = get_page_from_gfn(od, idx, &p2mt, P2M_ALLOC);\n        if ( !page )\n        {\n            rcu_unlock_domain(od);\n            return -EINVAL;\n        }\n\n        if ( !p2m_is_ram(p2mt) )\n        {\n            put_page(page);\n            rcu_unlock_domain(od);\n            return -EINVAL;\n        }\n\n        mfn = page_to_mfn(page);\n        t = p2m_map_foreign;\n\n        rcu_unlock_domain(od);\n        break;\n    }\n\n    default:\n        return -ENOSYS;\n    }\n\n    \/* Map at new location. *\/\n    rc = guest_physmap_add_entry(d, gpfn, mfn, 0, t);\n\n    return rc;\n}\n","1_CVE_2005_0146_VULN_nsTextEditorMouseListener__MouseClick":"nsresult\nCVE_2005_0146_VULN_nsTextEditorMouseListener::MouseClick(nsIDOMEvent* aMouseEvent)\n{\n  nsCOMPtr<nsIDOMMouseEvent> mouseEvent ( do_QueryInterface(aMouseEvent) );\n  if (!mouseEvent) {\n    \/\/non-ui event passed in.  bad things.\n    return NS_OK;\n  }\n\n  nsCOMPtr<nsIEditor> editor = do_QueryInterface(mEditor);\n  if (!editor) { return NS_OK; }\n\n  \/\/ If we got a mouse down inside the editing area, we should force the \n  \/\/ IME to commit before we change the cursor position\n  nsCOMPtr<nsIEditorIMESupport> imeEditor = do_QueryInterface(mEditor);\n  if (imeEditor)\n    imeEditor->ForceCompositionEnd();\n\n  PRUint16 button = (PRUint16)-1;\n  mouseEvent->GetButton(&button);\n  \/\/ middle-mouse click (paste);\n  if (button == 1)\n  {\n    nsresult rv;\n    nsCOMPtr<nsIPrefBranch> prefBranch =\n      do_GetService(NS_PREFSERVICE_CONTRACTID, &rv);\n    if (NS_SUCCEEDED(rv) && prefBranch)\n    {\n      PRBool doMiddleMousePaste = PR_FALSE;;\n      rv = prefBranch->GetBoolPref(\"middlemouse.paste\", &doMiddleMousePaste);\n      if (NS_SUCCEEDED(rv) && doMiddleMousePaste)\n      {\n        \/\/ Set the selection to the point under the mouse cursor:\n        nsCOMPtr<nsIDOMNSUIEvent> nsuiEvent (do_QueryInterface(aMouseEvent));\n        if (!nsuiEvent)\n          return NS_ERROR_NULL_POINTER;\n        nsCOMPtr<nsIDOMNode> parent;\n        if (NS_FAILED(nsuiEvent->GetRangeParent(getter_AddRefs(parent))))\n          return NS_ERROR_NULL_POINTER;\n        PRInt32 offset = 0;\n        if (NS_FAILED(nsuiEvent->GetRangeOffset(&offset)))\n          return NS_ERROR_NULL_POINTER;\n\n        nsCOMPtr<nsISelection> selection;\n        if (NS_SUCCEEDED(editor->GetSelection(getter_AddRefs(selection))))\n          (void)selection->Collapse(parent, offset);\n\n        \/\/ If the ctrl key is pressed, we'll do paste as quotation.\n        \/\/ Would've used the alt key, but the kde wmgr treats alt-middle specially. \n        PRBool ctrlKey = PR_FALSE;\n        mouseEvent->GetCtrlKey(&ctrlKey);\n\n        nsCOMPtr<nsIEditorMailSupport> mailEditor;\n        if (ctrlKey)\n          mailEditor = do_QueryInterface(mEditor);\n\n        PRInt32 clipboard;\n\n#if defined(XP_OS2) || defined(XP_WIN32)\n        clipboard = nsIClipboard::kGlobalClipboard;\n#else\n        clipboard = nsIClipboard::kSelectionClipboard;\n#endif\n\n        if (mailEditor)\n          mailEditor->PasteAsQuotation(clipboard);\n        else\n          editor->Paste(clipboard);\n\n        \/\/ Prevent the event from bubbling up to be possibly handled\n        \/\/ again by the containing window:\n        nsCOMPtr<nsIDOMNSEvent> nsevent(do_QueryInterface(mouseEvent));\n\n        if (nsevent) {\n          nsevent->PreventBubble();\n        }\n\n        mouseEvent->PreventDefault();\n\n        \/\/ We processed the event, whether drop\/paste succeeded or not\n        return NS_OK;\n      }\n    }\n  }\n  return NS_OK;\n}\n","1_CVE_2005_2492_VULN_rawv6_probe_proto_opt":"static void CVE_2005_2492_VULN_rawv6_probe_proto_opt(struct flowi *fl, struct msghdr *msg)\n{\n\tstruct iovec *iov;\n\tu8 __user *type = NULL;\n\tu8 __user *code = NULL;\n\tint probed = 0;\n\tint i;\n\n\tif (!msg->msg_iov)\n\t\treturn;\n\n\tfor (i = 0; i < msg->msg_iovlen; i++) {\n\t\tiov = &msg->msg_iov[i];\n\t\tif (!iov)\n\t\t\tcontinue;\n\n\t\tswitch (fl->proto) {\n\t\tcase IPPROTO_ICMPV6:\n\t\t\t\/* check if one-byte field is readable or not. *\/\n\t\t\tif (iov->iov_base && iov->iov_len < 1)\n\t\t\t\tbreak;\n\n\t\t\tif (!type) {\n\t\t\t\ttype = iov->iov_base;\n\t\t\t\t\/* check if code field is readable or not. *\/\n\t\t\t\tif (iov->iov_len > 1)\n\t\t\t\t\tcode = type + 1;\n\t\t\t} else if (!code)\n\t\t\t\tcode = iov->iov_base;\n\n\t\t\tif (type && code) {\n\t\t\t\tget_user(fl->fl_icmp_type, type);\n\t\t\t\t__get_user(fl->fl_icmp_code, code);\n\t\t\t\tprobed = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprobed = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (probed)\n\t\t\tbreak;\n\t}\n}\n","1_CVE_2005_2617_VULN_syscall32_setup_pages":"int CVE_2005_2617_VULN_syscall32_setup_pages(struct linux_binprm *bprm, int exstack)\n{\n\tint npages = (VSYSCALL32_END - VSYSCALL32_BASE) >> PAGE_SHIFT;\n\tstruct vm_area_struct *vma;\n\tstruct mm_struct *mm = current->mm;\n\n\tvma = kmem_cache_alloc(vm_area_cachep, SLAB_KERNEL);\n\tif (!vma)\n\t\treturn -ENOMEM;\n\tif (security_vm_enough_memory(npages)) {\n\t\tkmem_cache_free(vm_area_cachep, vma);\n\t\treturn -ENOMEM;\n\t}\n\n\tmemset(vma, 0, sizeof(struct vm_area_struct));\n\t\/* Could randomize here *\/\n\tvma->vm_start = VSYSCALL32_BASE;\n\tvma->vm_end = VSYSCALL32_END;\n\t\/* MAYWRITE to allow gdb to COW and set breakpoints *\/\n\tvma->vm_flags = VM_READ|VM_EXEC|VM_MAYREAD|VM_MAYEXEC|VM_MAYEXEC|VM_MAYWRITE;\n\tvma->vm_flags |= mm->def_flags;\n\tvma->vm_page_prot = protection_map[vma->vm_flags & 7];\n\tvma->vm_ops = &syscall32_vm_ops;\n\tvma->vm_mm = mm;\n\n\tdown_write(&mm->mmap_sem);\n\tinsert_vm_struct(mm, vma);\n\tmm->total_vm += npages;\n\tup_write(&mm->mmap_sem);\n\treturn 0;\n}\n","1_CVE_2005_2800_VULN_dev_seq_next":"static void * CVE_2005_2800_VULN_dev_seq_next(struct seq_file *s, void *v, loff_t *pos)\n{\n\tstruct sg_proc_deviter * it = (struct sg_proc_deviter *) v;\n\n\t*pos = ++it->index;\n\treturn (it->index < it->max) ? it : NULL;\n}\n","1_CVE_2005_2800_VULN_dev_seq_start":"static void * CVE_2005_2800_VULN_dev_seq_start(struct seq_file *s, loff_t *pos)\n{\n\tstruct sg_proc_deviter * it = kmalloc(sizeof(*it), GFP_KERNEL);\n\n\tif (! it)\n\t\treturn NULL;\n\tif (NULL == sg_dev_arr)\n\t\tgoto err1;\n\tit->index = *pos;\n\tit->max = sg_last_dev();\n\tif (it->index >= it->max)\n\t\tgoto err1;\n\treturn it;\nerr1:\n\tkfree(it);\n\treturn NULL;\n}\n","1_CVE_2005_3181_VULN_open_namei":"int CVE_2005_3181_VULN_open_namei(const char * pathname, int flag, int mode, struct nameidata *nd)\n{\n\tint acc_mode, error = 0;\n\tstruct path path;\n\tstruct dentry *dir;\n\tint count = 0;\n\n\tacc_mode = ACC_MODE(flag);\n\n\t\/* Allow the LSM permission hook to distinguish append \n\t   access from general write access. *\/\n\tif (flag & O_APPEND)\n\t\tacc_mode |= MAY_APPEND;\n\n\t\/* Fill in the open() intent data *\/\n\tnd->intent.open.flags = flag;\n\tnd->intent.open.create_mode = mode;\n\n\t\/*\n\t * The simplest case - just a plain lookup.\n\t *\/\n\tif (!(flag & O_CREAT)) {\n\t\terror = path_lookup(pathname, lookup_flags(flag)|LOOKUP_OPEN, nd);\n\t\tif (error)\n\t\t\treturn error;\n\t\tgoto ok;\n\t}\n\n\t\/*\n\t * Create - we need to know the parent.\n\t *\/\n\terror = path_lookup(pathname, LOOKUP_PARENT|LOOKUP_OPEN|LOOKUP_CREATE, nd);\n\tif (error)\n\t\treturn error;\n\n\t\/*\n\t * We have the parent and last component. First of all, check\n\t * that we are not asked to creat(2) an obvious directory - that\n\t * will not do.\n\t *\/\n\terror = -EISDIR;\n\tif (nd->last_type != LAST_NORM || nd->last.name[nd->last.len])\n\t\tgoto exit;\n\n\tdir = nd->dentry;\n\tnd->flags &= ~LOOKUP_PARENT;\n\tdown(&dir->d_inode->i_sem);\n\tpath.dentry = __lookup_hash(&nd->last, nd->dentry, nd);\n\tpath.mnt = nd->mnt;\n\ndo_last:\n\terror = PTR_ERR(path.dentry);\n\tif (IS_ERR(path.dentry)) {\n\t\tup(&dir->d_inode->i_sem);\n\t\tgoto exit;\n\t}\n\n\t\/* Negative dentry, just create the file *\/\n\tif (!path.dentry->d_inode) {\n\t\tif (!IS_POSIXACL(dir->d_inode))\n\t\t\tmode &= ~current->fs->umask;\n\t\terror = vfs_create(dir->d_inode, path.dentry, mode, nd);\n\t\tup(&dir->d_inode->i_sem);\n\t\tdput(nd->dentry);\n\t\tnd->dentry = path.dentry;\n\t\tif (error)\n\t\t\tgoto exit;\n\t\t\/* Don't check for write permission, don't truncate *\/\n\t\tacc_mode = 0;\n\t\tflag &= ~O_TRUNC;\n\t\tgoto ok;\n\t}\n\n\t\/*\n\t * It already exists.\n\t *\/\n\tup(&dir->d_inode->i_sem);\n\n\terror = -EEXIST;\n\tif (flag & O_EXCL)\n\t\tgoto exit_dput;\n\n\tif (__follow_mount(&path)) {\n\t\terror = -ELOOP;\n\t\tif (flag & O_NOFOLLOW)\n\t\t\tgoto exit_dput;\n\t}\n\terror = -ENOENT;\n\tif (!path.dentry->d_inode)\n\t\tgoto exit_dput;\n\tif (path.dentry->d_inode->i_op && path.dentry->d_inode->i_op->follow_link)\n\t\tgoto do_link;\n\n\tdput(nd->dentry);\n\tnd->dentry = path.dentry;\n\tif (nd->mnt != path.mnt)\n\t\tmntput(nd->mnt);\n\tnd->mnt = path.mnt;\n\terror = -EISDIR;\n\tif (path.dentry->d_inode && S_ISDIR(path.dentry->d_inode->i_mode))\n\t\tgoto exit;\nok:\n\terror = may_open(nd, acc_mode, flag);\n\tif (error)\n\t\tgoto exit;\n\treturn 0;\n\nexit_dput:\n\tdput(path.dentry);\n\tif (nd->mnt != path.mnt)\n\t\tmntput(path.mnt);\nexit:\n\tpath_release(nd);\n\treturn error;\n\ndo_link:\n\terror = -ELOOP;\n\tif (flag & O_NOFOLLOW)\n\t\tgoto exit_dput;\n\t\/*\n\t * This is subtle. Instead of calling do_follow_link() we do the\n\t * thing by hands. The reason is that this way we have zero link_count\n\t * and path_walk() (called from ->follow_link) honoring LOOKUP_PARENT.\n\t * After that we have the parent and last component, i.e.\n\t * we are in the same situation as after the first path_walk().\n\t * Well, almost - if the last component is normal we get its copy\n\t * stored in nd->last.name and we will have to putname() it when we\n\t * are done. Procfs-like symlinks just set LAST_BIND.\n\t *\/\n\tnd->flags |= LOOKUP_PARENT;\n\terror = security_inode_follow_link(path.dentry, nd);\n\tif (error)\n\t\tgoto exit_dput;\n\terror = __do_follow_link(&path, nd);\n\tif (error)\n\t\treturn error;\n\tnd->flags &= ~LOOKUP_PARENT;\n\tif (nd->last_type == LAST_BIND)\n\t\tgoto ok;\n\terror = -EISDIR;\n\tif (nd->last_type != LAST_NORM)\n\t\tgoto exit;\n\tif (nd->last.name[nd->last.len]) {\n\t\tputname(nd->last.name);\n\t\tgoto exit;\n\t}\n\terror = -ELOOP;\n\tif (count++==32) {\n\t\tputname(nd->last.name);\n\t\tgoto exit;\n\t}\n\tdir = nd->dentry;\n\tdown(&dir->d_inode->i_sem);\n\tpath.dentry = __lookup_hash(&nd->last, nd->dentry, nd);\n\tpath.mnt = nd->mnt;\n\tputname(nd->last.name);\n\tgoto do_last;\n}\n","1_CVE_2005_3356_VULN_do_create":"static struct file *CVE_2005_3356_VULN_do_create(struct dentry *dir, struct dentry *dentry,\n\t\t\tint oflag, mode_t mode, struct mq_attr __user *u_attr)\n{\n\tstruct file *filp;\n\tstruct mq_attr attr;\n\tint ret;\n\n\tif (u_attr != NULL) {\n\t\tif (copy_from_user(&attr, u_attr, sizeof(attr)))\n\t\t\treturn ERR_PTR(-EFAULT);\n\t\tif (!mq_attr_ok(&attr))\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\t\/* store for use during create *\/\n\t\tdentry->d_fsdata = &attr;\n\t}\n\n\tret = vfs_create(dir->d_inode, dentry, mode, NULL);\n\tdentry->d_fsdata = NULL;\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tfilp = dentry_open(dentry, mqueue_mnt, oflag);\n\tif (!IS_ERR(filp))\n\t\tdget(dentry);\n\n\treturn filp;\n}\n","1_CVE_2005_3356_VULN_do_open":"static struct file *CVE_2005_3356_VULN_do_open(struct dentry *dentry, int oflag)\n{\nstatic int oflag2acc[O_ACCMODE] = { MAY_READ, MAY_WRITE,\n\t\t\t\t\tMAY_READ | MAY_WRITE };\n\tstruct file *filp;\n\n\tif ((oflag & O_ACCMODE) == (O_RDWR | O_WRONLY))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (permission(dentry->d_inode, oflag2acc[oflag & O_ACCMODE], NULL))\n\t\treturn ERR_PTR(-EACCES);\n\n\tfilp = dentry_open(dentry, mqueue_mnt, oflag);\n\n\tif (!IS_ERR(filp))\n\t\tdget(dentry);\n\n\treturn filp;\n}\n","1_CVE_2005_3356_VULN_mq_attr_ok":"static int CVE_2005_3356_VULN_mq_attr_ok(struct mq_attr *attr)\n{\n\tif (attr->mq_maxmsg <= 0 || attr->mq_msgsize <= 0)\n\t\treturn 0;\n\tif (capable(CAP_SYS_RESOURCE)) {\n\t\tif (attr->mq_maxmsg > HARD_MSGMAX)\n\t\t\treturn 0;\n\t} else {\n\t\tif (attr->mq_maxmsg > msg_max ||\n\t\t\t\tattr->mq_msgsize > msgsize_max)\n\t\t\treturn 0;\n\t}\n\t\/* check for overflow *\/\n\tif (attr->mq_msgsize > ULONG_MAX\/attr->mq_maxmsg)\n\t\treturn 0;\n\tif ((unsigned long)(attr->mq_maxmsg * attr->mq_msgsize) +\n\t    (attr->mq_maxmsg * sizeof (struct msg_msg *)) <\n\t    (unsigned long)(attr->mq_maxmsg * attr->mq_msgsize))\n\t\treturn 0;\n\treturn 1;\n}\n","1_CVE_2005_3356_VULN_sys_mq_open":"asmlinkage long CVE_2005_3356_VULN_sys_mq_open(const char __user *u_name, int oflag, mode_t mode,\n\t\t\t\tstruct mq_attr __user *u_attr)\n{\n\tstruct dentry *dentry;\n\tstruct file *filp;\n\tchar *name;\n\tint fd, error;\n\n\tif (IS_ERR(name = getname(u_name)))\n\t\treturn PTR_ERR(name);\n\n\tfd = get_unused_fd();\n\tif (fd < 0)\n\t\tgoto out_putname;\n\n\tdown(&mqueue_mnt->mnt_root->d_inode->i_sem);\n\tdentry = lookup_one_len(name, mqueue_mnt->mnt_root, strlen(name));\n\tif (IS_ERR(dentry)) {\n\t\terror = PTR_ERR(dentry);\n\t\tgoto out_err;\n\t}\n\tmntget(mqueue_mnt);\n\n\tif (oflag & O_CREAT) {\n\t\tif (dentry->d_inode) {\t\/* entry already exists *\/\n\t\t\tfilp = (oflag & O_EXCL) ? ERR_PTR(-EEXIST) :\n\t\t\t\t\tdo_open(dentry, oflag);\n\t\t} else {\n\t\t\tfilp = do_create(mqueue_mnt->mnt_root, dentry,\n\t\t\t\t\t\toflag, mode, u_attr);\n\t\t}\n\t} else\n\t\tfilp = (dentry->d_inode) ? do_open(dentry, oflag) :\n\t\t\t\t\tERR_PTR(-ENOENT);\n\n\tdput(dentry);\n\n\tif (IS_ERR(filp)) {\n\t\terror = PTR_ERR(filp);\n\t\tgoto out_putfd;\n\t}\n\n\tset_close_on_exec(fd, 1);\n\tfd_install(fd, filp);\n\tgoto out_upsem;\n\nout_putfd:\n\tmntput(mqueue_mnt);\n\tput_unused_fd(fd);\nout_err:\n\tfd = error;\nout_upsem:\n\tup(&mqueue_mnt->mnt_root->d_inode->i_sem);\nout_putname:\n\tputname(name);\n\treturn fd;\n}\n"}}